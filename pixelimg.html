<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PixelForge - Client-Side Pixel Art Converter</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/lucide@latest"></script>
    <style>
        /* Custom Scrollbar */
        .custom-scrollbar::-webkit-scrollbar { width: 6px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #1e293b; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #475569; border-radius: 3px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #64748b; }
        
        /* Range Slider Styling */
        input[type=range] {
            -webkit-appearance: none;
            width: 100%;
            background: transparent;
        }
        input[type=range]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: #6366f1;
            cursor: pointer;
            margin-top: -6px;
        }
        input[type=range]::-webkit-slider-runnable-track {
            width: 100%;
            height: 4px;
            cursor: pointer;
            background: #334155;
            border-radius: 2px;
        }
        
        /* Pixelated Rendering Class */
        .pixelated {
            image-rendering: pixelated;
            image-rendering: -moz-crisp-edges;
            image-rendering: crisp-edges;
        }

        /* Hide/Show logic */
        .hidden { display: none !important; }
    </style>
</head>
<body class="bg-slate-900 text-slate-200 font-sans selection:bg-indigo-500 selection:text-white overflow-hidden h-screen flex flex-col md:flex-row">

    <!-- MOBILE HEADER -->
    <div class="md:hidden bg-slate-800 p-4 flex justify-between items-center border-b border-slate-700 z-10 shrink-0">
        <div class="flex items-center gap-2">
            <div class="w-8 h-8 bg-gradient-to-tr from-indigo-500 to-purple-500 rounded flex items-center justify-center font-bold text-white">P</div>
            <h1 class="font-bold tracking-tight">PixelForge</h1>
        </div>
        <button id="reset-mobile" class="text-slate-400 hover:text-white">
            <i data-lucide="refresh-cw"></i>
        </button>
    </div>

    <!-- LEFT COLUMN: PREVIEW AREA -->
    <div class="flex-1 relative bg-slate-950 flex flex-col justify-center items-center overflow-hidden" style="background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAQAAAAECAYAAACp8Z5+AAAAIklEQVQIW2NkQAKrVq36zwjjgzhhYWGMYAEYB8RmROaABADeOQ8CXl/xfgAAAABJRU5ErkJggg==');">
        
        <!-- Upload State -->
        <div id="upload-container" class="text-center p-8 border-2 border-dashed border-slate-700 rounded-2xl bg-slate-900/80 max-w-sm w-full transition-all">
            <div class="w-16 h-16 bg-slate-800 rounded-full flex items-center justify-center mx-auto mb-4 text-indigo-400">
                <i data-lucide="upload" size="32"></i>
            </div>
            <h3 class="text-xl font-bold text-white mb-2">Upload Image</h3>
            <p class="text-slate-400 mb-6 text-sm">Drag & drop or click to select</p>
            <input type="file" id="file-input" class="hidden" accept="image/*">
            <button onclick="document.getElementById('file-input').click()" class="w-full px-4 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-medium transition-colors shadow-lg shadow-indigo-500/20 flex items-center justify-center gap-2">
                <i data-lucide="image"></i> Select Photo
            </button>
        </div>

        <!-- Canvas Container -->
        <div id="canvas-container" class="relative hidden shadow-2xl shadow-black/50 group max-w-full max-h-[70vh] p-4">
            <!-- Offscreen source canvas (hidden) -->
            <canvas id="source-canvas" class="hidden"></canvas>
            <!-- Preview Image (Source for visual) -->
            <img id="preview-image" class="pixelated max-w-full max-h-[60vh] md:max-h-[80vh] object-contain border-4 border-slate-800 bg-slate-800 shadow-[0_0_0_1px_rgba(255,255,255,0.1)]" />
            
            <!-- Grid Overlay -->
            <div id="grid-overlay" class="absolute inset-0 pointer-events-none opacity-30 hidden" style="top: 4px; left: 4px; right: 4px; bottom: 4px;"></div>
            
            <!-- Loading Spinner -->
            <div id="loading-overlay" class="absolute inset-0 bg-black/60 flex items-center justify-center backdrop-blur-sm hidden z-50 rounded">
                <i data-lucide="loader-2" class="animate-spin text-indigo-400 w-8 h-8"></i>
            </div>
        </div>

        <!-- Floating Toolbar -->
        <div id="floating-toolbar" class="absolute bottom-6 left-1/2 -translate-x-1/2 bg-slate-800/90 backdrop-blur border border-slate-700 rounded-full px-4 py-2 flex items-center gap-4 shadow-xl z-20 hidden">
            <button id="btn-grid" class="p-2 text-slate-400 hover:text-white rounded-full transition-colors" title="Toggle Grid">
                <i data-lucide="grid"></i>
            </button>
            <div class="w-px h-6 bg-slate-600"></div>
            <button id="btn-close" class="p-2 text-red-400 hover:bg-red-900/30 rounded-full transition-colors" title="Close Image">
                <i data-lucide="x"></i>
            </button>
        </div>
    </div>

    <!-- RIGHT COLUMN: CONTROLS -->
    <div id="controls-panel" class="bg-slate-900 border-t md:border-t-0 md:border-l border-slate-700 w-full md:w-[360px] lg:w-[400px] flex flex-col z-20 shadow-2xl transition-all duration-300 h-0 md:h-screen overflow-hidden opacity-0 md:opacity-100">
        
        <!-- Tabs -->
        <div class="flex border-b border-slate-700 shrink-0">
            <button class="tab-btn flex-1 py-4 text-sm font-medium border-b-2 border-indigo-500 text-white bg-slate-800 transition-colors flex items-center justify-center gap-2" data-tab="process">
                <i data-lucide="settings" width="16"></i> Edit
            </button>
            <button class="tab-btn flex-1 py-4 text-sm font-medium border-b-2 border-transparent text-slate-400 hover:text-slate-200 transition-colors flex items-center justify-center gap-2" data-tab="palette">
                <i data-lucide="palette" width="16"></i> Colors
            </button>
            <button class="tab-btn flex-1 py-4 text-sm font-medium border-b-2 border-transparent text-slate-400 hover:text-slate-200 transition-colors flex items-center justify-center gap-2" data-tab="export">
                <i data-lucide="download" width="16"></i> Export
            </button>
        </div>

        <!-- Tab Content Wrapper -->
        <div class="flex-1 overflow-y-auto p-6 space-y-8 custom-scrollbar">
            
            <!-- TAB: PROCESS -->
            <div id="tab-process" class="tab-content space-y-6">
                <section>
                    <div class="flex items-center gap-2 mb-4">
                        <i data-lucide="monitor" class="text-indigo-400 w-5"></i>
                        <h3 class="font-bold text-white">Resolution</h3>
                    </div>
                    
                    <div class="mb-4">
                        <div class="flex justify-between mb-1">
                            <label class="text-sm font-medium text-slate-300">Pixel Size</label>
                            <span id="val-pixelSize" class="text-xs text-indigo-400 font-mono">8px</span>
                        </div>
                        <input type="range" id="inp-pixelSize" min="1" max="32" value="8" class="accent-indigo-500">
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-slate-300 mb-1">Sampling Method</label>
                        <select id="inp-pixelAlgo" class="w-full bg-slate-700 text-white text-sm rounded-lg p-2.5 border border-slate-600 focus:ring-indigo-500">
                            <option value="center">Crisp (Nearest Neighbor)</option>
                            <option value="average">Smooth (Block Average)</option>
                        </select>
                    </div>
                </section>

                <hr class="border-slate-800" />

                <section>
                    <div class="flex items-center gap-2 mb-4">
                        <i data-lucide="layers" class="text-indigo-400 w-5"></i>
                        <h3 class="font-bold text-white">Dithering</h3>
                    </div>
                    
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-slate-300 mb-1">Algorithm</label>
                        <select id="inp-ditherAlgo" class="w-full bg-slate-700 text-white text-sm rounded-lg p-2.5 border border-slate-600 focus:ring-indigo-500">
                            <option value="none">None (Solid Colors)</option>
                            <option value="bayer">Bayer (Ordered Pattern)</option>
                            <option value="floyd">Floyd-Steinberg (Diffusion)</option>
                        </select>
                    </div>

                    <div class="mb-4 hidden" id="group-ditherStrength">
                        <div class="flex justify-between mb-1">
                            <label class="text-sm font-medium text-slate-300">Intensity</label>
                            <span id="val-ditherStrength" class="text-xs text-indigo-400 font-mono">50%</span>
                        </div>
                        <input type="range" id="inp-ditherStrength" min="0" max="100" value="50" class="accent-indigo-500">
                    </div>
                </section>
            </div>

            <!-- TAB: PALETTE -->
            <div id="tab-palette" class="tab-content space-y-6 hidden">
                <section>
                    <div class="mb-4">
                        <label class="block text-sm font-medium text-slate-300 mb-1">Palette Mode</label>
                        <select id="inp-paletteMode" class="w-full bg-slate-700 text-white text-sm rounded-lg p-2.5 border border-slate-600 focus:ring-indigo-500">
                            <option value="auto">Auto Extract</option>
                            <option value="custom" disabled>Custom (Coming Soon)</option>
                        </select>
                    </div>
                    
                    <div class="mb-4">
                        <div class="flex justify-between mb-1">
                            <label class="text-sm font-medium text-slate-300">Color Count</label>
                            <span id="val-colorCount" class="text-xs text-indigo-400 font-mono">16</span>
                        </div>
                        <input type="range" id="inp-colorCount" min="2" max="64" value="16" class="accent-indigo-500">
                    </div>

                    <div class="mb-4">
                        <label class="block text-sm font-medium text-slate-300 mb-1">Reduction Engine</label>
                        <select id="inp-quantAlgo" class="w-full bg-slate-700 text-white text-sm rounded-lg p-2.5 border border-slate-600 focus:ring-indigo-500">
                            <option value="median">Median Cut (Balanced)</option>
                            <option value="kmeans">K-Means (Precise)</option>
                        </select>
                    </div>
                </section>

                <div class="bg-slate-800 rounded-lg p-4">
                    <h4 class="text-xs uppercase tracking-wider text-slate-500 font-bold mb-3">Active Colors</h4>
                    <div id="palette-grid" class="grid grid-cols-8 gap-1">
                        <!-- Colors injected here -->
                    </div>
                </div>
            </div>

            <!-- TAB: EXPORT -->
            <div id="tab-export" class="tab-content space-y-6 hidden">
                <div class="bg-slate-800 p-6 rounded-xl text-center space-y-4">
                    <div class="text-slate-400 text-sm">Output Dimensions</div>
                    <div class="flex gap-2 justify-center text-lg text-white font-mono font-bold">
                        <span id="export-dim-w">0</span>
                        <span class="text-slate-600">Ã—</span>
                        <span id="export-dim-h">0</span>
                    </div>
                </div>

                <button id="btn-download-png" class="w-full px-4 py-4 bg-indigo-600 hover:bg-indigo-700 text-white rounded-lg font-bold transition-all shadow-lg flex items-center justify-center gap-2">
                    <i data-lucide="download"></i> Download PNG
                </button>
                
                <button id="btn-download-tiles" class="w-full px-4 py-4 bg-slate-700 hover:bg-slate-600 text-slate-200 rounded-lg font-medium transition-all flex items-center justify-center gap-2">
                    <i data-lucide="layers"></i> Export Tileset (ZIP)
                </button>

                <p class="text-xs text-slate-500 text-center mt-2">Tileset export creates a placeholder in this demo.</p>
            </div>

        </div>

        <!-- Footer -->
        <div class="p-4 border-t border-slate-800 text-xs text-slate-600 text-center shrink-0">
            Client-side processing. No data leaves your device.
        </div>
    </div>


    <!-- WORKER SCRIPT (EMBEDDED) -->
    <script id="worker-code" type="javascript/worker">
        self.onmessage = async (e) => {
            const { imageData, config, id } = e.data;
            try {
                const result = processImage(imageData, config);
                self.postMessage({ id, success: true, result }, [result.pixels.data.buffer]);
            } catch (err) {
                self.postMessage({ id, success: false, error: err.message });
            }
        };

        function processImage(original, config) {
            const { pixelSize, pixelAlgo, colorCount, quantAlgo, ditherAlgo, ditherStrength, paletteMode } = config;
            
            // 1. Downscale
            const targetW = Math.max(1, Math.floor(original.width / pixelSize));
            const targetH = Math.max(1, Math.floor(original.height / pixelSize));
            const downscaled = new ImageData(targetW, targetH);
            
            // Sampling
            if (pixelAlgo === 'average') {
                for (let y = 0; y < targetH; y++) {
                    for (let x = 0; x < targetW; x++) {
                        let r = 0, g = 0, b = 0, a = 0, count = 0;
                        const startX = x * pixelSize;
                        const startY = y * pixelSize;
                        for (let py = 0; py < pixelSize; py++) {
                            for (let px = 0; px < pixelSize; px++) {
                                const sx = startX + px;
                                const sy = startY + py;
                                if (sx < original.width && sy < original.height) {
                                    const idx = (sy * original.width + sx) * 4;
                                    r += original.data[idx];
                                    g += original.data[idx+1];
                                    b += original.data[idx+2];
                                    a += original.data[idx+3];
                                    count++;
                                }
                            }
                        }
                        const tidx = (y * targetW + x) * 4;
                        downscaled.data[tidx] = r / count;
                        downscaled.data[tidx+1] = g / count;
                        downscaled.data[tidx+2] = b / count;
                        downscaled.data[tidx+3] = a / count;
                    }
                }
            } else {
                for (let y = 0; y < targetH; y++) {
                    for (let x = 0; x < targetW; x++) {
                        const sx = Math.floor((x * pixelSize) + (pixelSize / 2));
                        const sy = Math.floor((y * pixelSize) + (pixelSize / 2));
                        const safeX = Math.min(sx, original.width - 1);
                        const safeY = Math.min(sy, original.height - 1);
                        const sidx = (safeY * original.width + safeX) * 4;
                        const tidx = (y * targetW + x) * 4;
                        downscaled.data[tidx] = original.data[sidx];
                        downscaled.data[tidx+1] = original.data[sidx+1];
                        downscaled.data[tidx+2] = original.data[sidx+2];
                        downscaled.data[tidx+3] = original.data[sidx+3];
                    }
                }
            }

            // 2. Palette
            let palette = [];
            const pixels = [];
            for (let i = 0; i < downscaled.data.length; i += 4) {
                if (downscaled.data[i+3] > 128) {
                    pixels.push({ r: downscaled.data[i], g: downscaled.data[i+1], b: downscaled.data[i+2] });
                }
            }
            
            if (quantAlgo === 'kmeans') {
                palette = kMeans(pixels, colorCount);
            } else {
                palette = medianCut(pixels, colorCount);
            }

            // 3. Quantization & Dither
            const width = downscaled.width;
            const height = downscaled.height;
            const data = downscaled.data;

            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const oldR = data[idx];
                    const oldG = data[idx+1];
                    const oldB = data[idx+2];
                    const oldA = data[idx+3];

                    if (oldA < 128) { data[idx+3] = 0; continue; }

                    let threshold = 0;
                    if (ditherAlgo === 'bayer') {
                        const bayerMatrix = [[0, 8, 2, 10],[12, 4, 14, 6],[3, 11, 1, 9],[15, 7, 13, 5]];
                        const strength = ditherStrength * 32; 
                        const mapVal = bayerMatrix[y % 4][x % 4];
                        threshold = (mapVal / 16 - 0.5) * strength;
                    }

                    const closest = findClosest(oldR + threshold, oldG + threshold, oldB + threshold, palette);

                    data[idx] = closest.r;
                    data[idx+1] = closest.g;
                    data[idx+2] = closest.b;
                    data[idx+3] = 255;

                    if (ditherAlgo === 'floyd' && ditherStrength > 0) {
                        const errR = (oldR - closest.r) * ditherStrength;
                        const errG = (oldG - closest.g) * ditherStrength;
                        const errB = (oldB - closest.b) * ditherStrength;
                        distributeError(data, x, y, width, height, errR, errG, errB);
                    }
                }
            }

            return { pixels: downscaled, palette: palette };
        }

        // --- Helpers ---
        function findClosest(r, g, b, palette) {
            let minDist = Infinity;
            let closest = palette[0] || {r:0, g:0, b:0};
            for (let i = 0; i < palette.length; i++) {
                const p = palette[i];
                const dist = (r - p.r) ** 2 + (g - p.g) ** 2 + (b - p.b) ** 2;
                if (dist < minDist) { minDist = dist; closest = p; }
            }
            return closest;
        }

        function distributeError(data, x, y, w, h, er, eg, eb) {
            const addErr = (dx, dy, factor) => {
                if (x + dx >= 0 && x + dx < w && y + dy >= 0 && y + dy < h) {
                    const idx = ((y + dy) * w + (x + dx)) * 4;
                    data[idx] = Math.min(255, Math.max(0, data[idx] + er * factor));
                    data[idx+1] = Math.min(255, Math.max(0, data[idx+1] + eg * factor));
                    data[idx+2] = Math.min(255, Math.max(0, data[idx+2] + eb * factor));
                }
            };
            addErr(1, 0, 7/16); addErr(-1, 1, 3/16); addErr(0, 1, 5/16); addErr(1, 1, 1/16);
        }

        function medianCut(pixels, count) {
            if (pixels.length === 0) return [];
            const split = (buckets) => {
                if (buckets.length >= count) return buckets;
                let bestBucketIdx = -1, maxRange = -1, bestChannel = 'r';
                buckets.forEach((bucket, idx) => {
                    if (bucket.length === 0) return;
                    let minR=255, maxR=0, minG=255, maxG=0, minB=255, maxB=0;
                    bucket.forEach(p => {
                        minR = Math.min(minR, p.r); maxR = Math.max(maxR, p.r);
                        minG = Math.min(minG, p.g); maxG = Math.max(maxG, p.g);
                        minB = Math.min(minB, p.b); maxB = Math.max(maxB, p.b);
                    });
                    const rR=maxR-minR, rG=maxG-minG, rB=maxB-minB;
                    const max = Math.max(rR, rG, rB);
                    if (max > maxRange) { maxRange=max; bestBucketIdx=idx; bestChannel = max===rR?'r':max===rG?'g':'b'; }
                });
                if (bestBucketIdx === -1) return buckets;
                const bucket = buckets[bestBucketIdx];
                bucket.sort((a,b) => a[bestChannel]-b[bestChannel]);
                const mid = Math.floor(bucket.length/2);
                buckets.splice(bestBucketIdx, 1, bucket.slice(0,mid), bucket.slice(mid));
                return split(buckets);
            };
            const buckets = split([pixels]);
            return buckets.map(b => {
                if (b.length===0) return {r:0,g:0,b:0};
                let r=0,g=0,b=0; b.forEach(p=>{r+=p.r; g+=p.g; b+=p.b});
                return {r:Math.round(r/b.length), g:Math.round(g/b.length), b:Math.round(b/b.length)};
            });
        }

        function kMeans(pixels, k) {
            if (pixels.length <= k) return pixels;
            let centroids = [];
            for(let i=0; i<k; i++) centroids.push(pixels[Math.floor(Math.random()*pixels.length)]);
            for(let iter=0; iter<5; iter++) {
                const assignments = new Array(k).fill(0).map(()=>({r:0,g:0,b:0,count:0}));
                for(let i=0; i<pixels.length; i++) {
                    const p = pixels[i];
                    let minDist=Infinity, idx=0;
                    for(let j=0; j<k; j++) {
                        const c = centroids[j];
                        const dist = (p.r-c.r)**2 + (p.g-c.g)**2 + (p.b-c.b)**2;
                        if(dist < minDist) { minDist=dist; idx=j; }
                    }
                    assignments[idx].r+=p.r; assignments[idx].g+=p.g; assignments[idx].b+=p.b; assignments[idx].count++;
                }
                for(let j=0; j<k; j++) {
                    if(assignments[j].count>0) {
                        centroids[j] = {
                            r: Math.round(assignments[j].r/assignments[j].count),
                            g: Math.round(assignments[j].g/assignments[j].count),
                            b: Math.round(assignments[j].b/assignments[j].count)
                        };
                    }
                }
            }
            return centroids;
        }
    </script>

    <!-- MAIN APP SCRIPT -->
    <script>
        // --- Globals & State ---
        const state = {
            config: {
                pixelSize: 8,
                pixelAlgo: 'center',
                colorCount: 16,
                quantAlgo: 'median',
                ditherAlgo: 'none',
                ditherStrength: 0.5,
                paletteMode: 'auto'
            },
            originalImage: null, // Image Object
            processedData: null // { pixels: ImageData, palette: [] }
        };

        const els = {}; // Cache DOM elements
        let worker = null;
        let debounceTimer = null;

        // --- Init ---
        document.addEventListener('DOMContentLoaded', () => {
            lucide.createIcons();
            initElements();
            initWorker();
            initEventListeners();
        });

        function initElements() {
            const id = (i) => document.getElementById(i);
            els.uploadContainer = id('upload-container');
            els.canvasContainer = id('canvas-container');
            els.fileInput = id('file-input');
            els.previewImage = id('preview-image');
            els.sourceCanvas = id('source-canvas');
            els.gridOverlay = id('grid-overlay');
            els.loadingOverlay = id('loading-overlay');
            els.controlsPanel = id('controls-panel');
            els.paletteGrid = id('palette-grid');
            els.floatingToolbar = id('floating-toolbar');
            
            // Value Labels
            els.valPixelSize = id('val-pixelSize');
            els.valColorCount = id('val-colorCount');
            els.valDitherStrength = id('val-ditherStrength');

            // Inputs
            els.inpPixelSize = id('inp-pixelSize');
            els.inpPixelAlgo = id('inp-pixelAlgo');
            els.inpColorCount = id('inp-colorCount');
            els.inpQuantAlgo = id('inp-quantAlgo');
            els.inpDitherAlgo = id('inp-ditherAlgo');
            els.inpDitherStrength = id('inp-ditherStrength');
            els.inpPaletteMode = id('inp-paletteMode');
        }

        function initWorker() {
            const blob = new Blob([document.getElementById('worker-code').textContent], { type: "text/javascript" });
            worker = new Worker(window.URL.createObjectURL(blob));
            
            worker.onmessage = (e) => {
                const { success, result, error } = e.data;
                els.loadingOverlay.classList.add('hidden');
                
                if (success) {
                    state.processedData = result;
                    renderPreview();
                    updatePaletteUI(result.palette);
                    updateExportUI();
                } else {
                    console.error(error);
                    alert("Error processing image.");
                }
            };
        }

        function initEventListeners() {
            // Upload
            els.fileInput.addEventListener('change', handleFileSelect);
            document.body.addEventListener('dragover', e => e.preventDefault());
            document.body.addEventListener('drop', e => {
                e.preventDefault();
                if(e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
            });

            // Controls
            const bind = (el, key, type='int', cb) => {
                el.addEventListener('input', (e) => {
                    let val = e.target.value;
                    if(type==='int') val = parseInt(val);
                    if(type==='float') val = parseInt(val) / 100;
                    state.config[key] = val;
                    if(cb) cb(val);
                    triggerProcess();
                });
            };

            bind(els.inpPixelSize, 'pixelSize', 'int', v => els.valPixelSize.innerText = v + 'px');
            bind(els.inpColorCount, 'colorCount', 'int', v => els.valColorCount.innerText = v);
            bind(els.inpPixelAlgo, 'pixelAlgo', 'str');
            bind(els.inpQuantAlgo, 'quantAlgo', 'str');
            bind(els.inpPaletteMode, 'paletteMode', 'str');
            
            els.inpDitherAlgo.addEventListener('change', (e) => {
                state.config.ditherAlgo = e.target.value;
                const strengthGroup = document.getElementById('group-ditherStrength');
                if (e.target.value === 'none') strengthGroup.classList.add('hidden');
                else strengthGroup.classList.remove('hidden');
                triggerProcess();
            });

            bind(els.inpDitherStrength, 'ditherStrength', 'float', v => els.valDitherStrength.innerText = Math.round(v*100) + '%');

            // Toolbar
            document.getElementById('btn-grid').addEventListener('click', toggleGrid);
            document.getElementById('btn-close').addEventListener('click', resetApp);
            document.getElementById('reset-mobile').addEventListener('click', resetApp);

            // Tabs
            document.querySelectorAll('.tab-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.tab-btn').forEach(b => {
                        b.classList.remove('border-indigo-500', 'text-white', 'bg-slate-800');
                        b.classList.add('border-transparent', 'text-slate-400');
                    });
                    btn.classList.remove('border-transparent', 'text-slate-400');
                    btn.classList.add('border-indigo-500', 'text-white', 'bg-slate-800');
                    
                    document.querySelectorAll('.tab-content').forEach(c => c.classList.add('hidden'));
                    document.getElementById(`tab-${btn.dataset.tab}`).classList.remove('hidden');
                });
            });

            // Download
            document.getElementById('btn-download-png').addEventListener('click', () => downloadImage('png'));
            document.getElementById('btn-download-tiles').addEventListener('click', () => alert("Tileset generation requires external libraries. Use PNG for now!"));
        }

        // --- Core Logic ---

        function handleFileSelect(e) {
            if (e.target.files.length) handleFile(e.target.files[0]);
        }

        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const img = new Image();
                img.onload = () => {
                    state.originalImage = img;
                    els.uploadContainer.classList.add('hidden');
                    els.canvasContainer.classList.remove('hidden');
                    els.floatingToolbar.classList.remove('hidden');
                    els.controlsPanel.classList.remove('h-0', 'opacity-0');
                    els.controlsPanel.classList.add('h-[50vh]', 'md:h-screen', 'opacity-100');
                    triggerProcess();
                };
                img.src = e.target.result;
            };
            reader.readAsDataURL(file);
        }

        function triggerProcess() {
            if (!state.originalImage) return;
            
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                els.loadingOverlay.classList.remove('hidden');
                
                // Draw original to hidden canvas to get ImageData
                els.sourceCanvas.width = state.originalImage.width;
                els.sourceCanvas.height = state.originalImage.height;
                const ctx = els.sourceCanvas.getContext('2d');
                ctx.drawImage(state.originalImage, 0, 0);
                const imageData = ctx.getImageData(0, 0, state.originalImage.width, state.originalImage.height);

                worker.postMessage({
                    imageData: imageData,
                    config: state.config,
                    id: Date.now()
                });
            }, 100);
        }

        function renderPreview() {
            if (!state.processedData) return;
            
            // Draw tiny pixelated data to source canvas
            const { pixels } = state.processedData;
            els.sourceCanvas.width = pixels.width;
            els.sourceCanvas.height = pixels.height;
            const ctx = els.sourceCanvas.getContext('2d');
            ctx.putImageData(pixels, 0, 0);

            // Use data URL for the image element (let CSS scale it up)
            els.previewImage.src = els.sourceCanvas.toDataURL();

            // Update Grid logic
            updateGrid();
        }

        function updateGrid() {
            if (!state.processedData) return;
            const w = state.processedData.pixels.width;
            const h = state.processedData.pixels.height;
            
            // We can't easily draw lines on the <img>, so we use background size on overlay
            // Ideally we'd calculate aspect ratio, but CSS cover/contain makes it tricky.
            // Simplified: Just update background size assuming 100% fill for now.
            els.gridOverlay.style.backgroundSize = `${100/w}% ${100/h}%`;
            els.gridOverlay.style.backgroundImage = `
                linear-gradient(to right, rgba(255,255,255,0.3) 1px, transparent 1px),
                linear-gradient(to bottom, rgba(255,255,255,0.3) 1px, transparent 1px)
            `;
        }

        function toggleGrid() {
            els.gridOverlay.classList.toggle('hidden');
            const btn = document.getElementById('btn-grid');
            btn.classList.toggle('text-slate-400');
            btn.classList.toggle('text-indigo-400');
        }

        function updatePaletteUI(palette) {
            els.paletteGrid.innerHTML = '';
            palette.forEach(c => {
                const hex = `#${[c.r,c.g,c.b].map(x=>x.toString(16).padStart(2,'0')).join('')}`;
                const div = document.createElement('div');
                div.className = "aspect-square rounded-sm shadow-sm cursor-pointer hover:scale-110 transition-transform relative group bg-slate-700";
                div.style.backgroundColor = hex;
                div.title = hex;
                els.paletteGrid.appendChild(div);
            });
        }

        function updateExportUI() {
            if(!state.processedData) return;
            const scale = 16; // Export scale
            document.getElementById('export-dim-w').innerText = state.processedData.pixels.width * scale;
            document.getElementById('export-dim-h').innerText = state.processedData.pixels.height * scale;
        }

        function downloadImage(format) {
            if (!state.processedData) return;
            
            const scale = 16;
            const exportCanvas = document.createElement('canvas');
            exportCanvas.width = state.processedData.pixels.width * scale;
            exportCanvas.height = state.processedData.pixels.height * scale;
            const ctx = exportCanvas.getContext('2d');
            
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(els.sourceCanvas, 0, 0, exportCanvas.width, exportCanvas.height);

            // Draw Grid if active
            if (!els.gridOverlay.classList.contains('hidden')) {
                ctx.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx.lineWidth = 1;
                for (let x=0; x<=exportCanvas.width; x+=scale) {
                    ctx.beginPath(); ctx.moveTo(x,0); ctx.lineTo(x,exportCanvas.height); ctx.stroke();
                }
                for (let y=0; y<=exportCanvas.height; y+=scale) {
                    ctx.beginPath(); ctx.moveTo(0,y); ctx.lineTo(exportCanvas.width,y); ctx.stroke();
                }
            }

            const link = document.createElement('a');
            link.download = `pixelforge-${Date.now()}.png`;
            link.href = exportCanvas.toDataURL();
            link.click();
        }

        function resetApp() {
            state.originalImage = null;
            state.processedData = null;
            els.fileInput.value = '';
            els.previewImage.src = '';
            
            els.uploadContainer.classList.remove('hidden');
            els.canvasContainer.classList.add('hidden');
            els.floatingToolbar.classList.add('hidden');
            els.controlsPanel.classList.remove('h-[50vh]', 'md:h-screen', 'opacity-100');
            els.controlsPanel.classList.add('h-0', 'opacity-0');
        }

    </script>
</body>
</html>

