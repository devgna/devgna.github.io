<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CA328 - Cheat Sheet</title>
    <!-- Prism.js CSS for syntax highlighting (Tomorrow Night theme) -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-tomorrow.min.css">
    <!-- Simple styling for a clean, printable "doc-like" feel -->
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            line-height: 1.6;
            background-color: #f9f9f9;
            color: #333;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 800px;
            margin: 20px auto;
            padding: 30px;
            background-color: #ffffff;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
        }
        h1 {
            color: #1a73e8; /* Blue */
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
            font-size: 2.2em;
            font-weight: 600;
        }
        h2 {
            color: #d9534f; /* Red */
            border-bottom: 1px solid #f0f0f0;
            padding-bottom: 8px;
            margin-top: 40px;
            font-size: 1.8em;
            font-weight: 600;
        }
        h3 {
            color: #333;
            font-size: 1.3em;
            font-weight: 600;
            margin-top: 30px;
        }
        p {
            font-size: 1em;
            margin-bottom: 15px;
        }
        ul, ol {
            padding-left: 20px;
            margin-bottom: 15px;
        }
        li {
            margin-bottom: 8px;
        }
        pre {
            border-radius: 5px;
            font-size: 0.95em;
        }
        code {
            font-family: "Courier New", Courier, monospace;
            font-size: 0.95em; /* Ensure code font size matches pre */
        }
        .note {
            background-color: #fffbdd;
            border: 1px solid #ffeb3b;
            padding: 15px;
            border-radius: 5px;
            margin-top: 15px;
        }
        /* NEW: Real-world example box */
        .example {
            background-color: #fffaf0; /* Light orange/cream */
            border: 1px solid #ffe0b2; /* Orange border */
            padding: 15px;
            border-radius: 8px;
            margin-top: 15px;
            font-size: 0.95em;
            line-height: 1.5;
        }
        .example strong {
            color: #e65100; /* Dark orange */
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background-color: #f2f2f2;
            font-weight: 600;
        }
        tr:nth-child(even) {
            background-color: #f9f9f9;
        }

        /* Styles for diagrams */
        .diagram {
            margin: 20px 0;
            padding: 15px;
            background-color: #fdfdfd;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            text-align: center;
        }
        .diagram-title {
            font-weight: 600;
            margin-bottom: 15px;
            color: #333;
        }
        .diagram-box, .concept-box {
            background-color: #e3f2fd; /* Light blue */
            border: 1px solid #90caf9; /* Blue border */
            color: #1e88e5; /* Blue text */
            padding: 10px 15px;
            border-radius: 8px;
            display: inline-block;
            margin: 5px;
            min-width: 120px;
            text-align: center;
            vertical-align: middle;
        }
        .concept-box-alt {
            background-color: #e8f5e9; /* Light green */
            border: 1px solid #a5d6a7; /* Green border */
            color: #2e7d32; /* Green text */
        }
        .concept-box-red {
            background-color: #ffebee; /* Light red */
            border: 1px solid #ef9a9a; /* Red border */
            color: #c62828; /* Red text */
        }
        .concept-box-grey {
            background-color: #f5f5f5; /* Grey */
            border: 1px solid #e0e0e0; /* Grey border */
            color: #424242; /* Grey text */
        }
        .arrow {
            font-size: 24px;
            font-weight: bold;
            color: #757575;
            margin: 0 10px;
            display: inline-block;
            vertical-align: middle;
        }
        .arrow-down {
            font-size: 24px;
            font-weight: bold;
            color: #757575;
            display: block;
            margin: 5px auto;
        }
        .flex-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap;
        }
        .flex-column {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>CA328: Fundamentals of Visual Programming - Cheat Sheet</h1>
        <p class="note">
            <strong>Note:</strong> As requested, this cheat sheet includes theory for Unit 4 but excludes its code questions. Unit 6 is omitted entirely. Questions are predicted based on the provided Question Bank, Sessional Paper, and Syllabus.
        </p>

        <!-- Unit 1: Introduction to .NET Framework -->
        <h2>Unit 1: Introduction to .NET Framework</h2>

        <h3>1. Define CLR (Common Language Runtime) and explain its role.</h3>
        <p>The <strong>CLR (Common Language Runtime)</strong> is the core execution engine of the .NET Framework. It's an environment that manages the execution of .NET code (managed code).</p>
        <p><strong>Key Roles:</strong></p>
        <ul>
            <li><strong>MSIL to Native Code:</strong> It converts the intermediate code (MSIL or CIL) into native machine code using a Just-In-Time (JIT) compiler.</li>
            <li><strong>Memory Management:</strong> It automatically handles memory, most importantly through <strong>Garbage Collection (GC)</strong>, which reclaims memory from objects that are no longer in use.</li>
            <li><strong>Security:</strong> It provides services like Code Access Security (CAS) to prevent unauthorized access.</li>
            <li><strong>Exception Handling:</strong> It provides a standard way to handle errors (exceptions) across different .NET languages.</li>
            <li><strong>Type Safety:</strong> It enforces the Common Type System (CTS) to ensure that different .NET languages can interact safely.</li>
        </ul>
        <div class="diagram">
            <div class="diagram-title">CLR Execution Flow</div>
            <div class="flex-container">
                <div class="flex-column">
                    <div class="diagram-box concept-box-alt">C# Code</div>
                    <div class="diagram-box concept-box-alt" style="margin-top: 5px;">VB.NET Code</div>
                </div>
                <div class="arrow">&rarr;</div>
                <div class="diagram-box">Language<br>Compiler</div>
                <div class="arrow">&rarr;</div>
                <div class="diagram-box">MSIL Code<br>(Intermediate)</div>
                <div class="arrow">&rarr;</div>
                <div class="diagram-box concept-box-red">CLR<br>(JIT, GC, Security)</div>
                <div class="arrow">&rarr;</div>
                <div class="diagram-box concept-box-grey">Native Code<br>(Machine-Specific)</div>
            </div>
        </div>
        <div class="example">
            <strong>Real-world Example:</strong> Think of the CLR as a highly-skilled translator and event manager at the UN.
            <ul>
                <li>Speakers (C#, VB.NET) write their speeches (code) in their own language.</li>
                <li>A compiler translates them into a common "UN-speak" (MSIL).</li>
                <li>The <strong>CLR (manager)</strong> is in the room:
                    <ul>
                        <li>It translates that "UN-speak" into the *specific* language of the listening diplomats (Native Code) *just-in-time* as they speak (JIT).</li>
                        <li>It provides security, checking everyone's badges (CAS).</li>
                        <li>It automatically cleans up the water glasses and trash left behind (Garbage Collection).</li>
                    </ul>
                </li>
            </ul>
        </div>

        <h3>2. Describe the .NET Framework architecture.</h3>
        <p>The .NET Framework architecture is a layered model that provides services for building, deploying, and running applications.</p>
        <div class="diagram">
            <div class="diagram-title">.NET Framework Architecture</div>
            <div class="flex-column">
                <div class="diagram-box concept-box-alt" style="width: 300px;">Windows Forms | ASP.NET | WPF (Your Apps)</div>
                <div class="arrow-down">&darr;</div>
                <div class="diagram-box" style="width: 300px;">Framework Class Library (FCL)</div>
                <div class="arrow-down">&darr;</div>
                <div class="diagram-box" style="width: 300px;">Common Language Specification (CLS) | Common Type System (CTS)</div>
                <div class="arrow-down">&darr;</div>
                <div class="diagram-box concept-box-red" style="width: 300px;">Common Language Runtime (CLR)</div>
                <div class="arrow-down">&darr;</div>
                <div class="diagram-box concept-box-grey" style="width: 300px;">Operating System (OS)</div>
            </div>
        </div>
        <p><strong>Main Components:</strong></p>
        <ol>
            <li><strong>Common Language Runtime (CLR):</strong> The "engine" at the bottom that executes code.</li>
            <li><strong>Framework Class Library (FCL):</strong> A huge library of pre-written, reusable code (e.g., code for database access, file I/O, string manipulation).</li>
            <li><strong>Common Language Specification (CLS):</strong> A set of rules that languages must follow to be able to "talk" to each other.</li>
            <li><strong>Common Type System (CTS):</strong> Defines a set of common data types that all .NET languages share.</li>
            <li><strong>Application Layers (WPF, ASP.NET, etc.):</strong> The types of applications you can build.</li>
        </ol>
        <div class="example">
            <strong>Real-world Example:</strong> It's like building with LEGOs.
            <ul>
                <li>The **Operating System** is the floor.</li>
                <li>The **CLR** is the big, flat green LEGO baseplate you build on.</li>
                <li>The **FCL** is a giant box of pre-built LEGO pieces (wheels, doors, windows, etc.).</li>
                <li>The **CLS/CTS** are the "studs" and "holes" that guarantee all pieces, no matter which box they came from, will snap together.</li>
                <li>**Your App (WPF)** is the final car or house you build.</li>
            </ul>
        </div>

        <h3>3. Explain the difference between Managed and Unmanaged Code.</h3>
        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>Managed Code</th>
                    <th>Unmanaged Code</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Execution</strong></td>
                    <td>Executed *by* the CLR. The CLR manages its entire lifecycle.</td>
                    <td>Executed *directly* by the Operating System (CPU).</td>
                </tr>
                <tr>
                    <td><strong>Memory</strong></td>
                    <td>Memory is managed automatically by the Garbage Collector (GC).</td>
                    <td>Programmer is responsible for all memory allocation and de-allocation.</td>
                </tr>
                <tr>
                    <td><strong>Services</strong></td>
                    <td>Benefits from CLR services (type safety, security, exception handling).</td>
                    <td>Does not get any services from the CLR.</td>
                </tr>
                <tr>
                    <td><strong>Example</strong></td>
                    <td>C#, VB.NET</td>
                    <td>C, C++ (traditional)</td>
                </tr>
            </tbody>
        </table>
        <div class="diagram">
            <div class="diagram-title">Managed vs. Unmanaged Code</div>
            <div class="flex-container">
                <div class="flex-column" style="margin-right: 20px;">
                    <div class="diagram-title">Managed Flow</div>
                    <div class="diagram-box concept-box-alt">Your C# Code</div>
                    <div class="arrow-down">&darr;</div>
                    <div class="diagram-box concept-box-red">CLR (Manager)</div>
                    <div class="arrow-down">&darr;</div>
                    <div class="diagram-box concept-box-grey">Operating System</div>
                </div>
                <div class="flex-column" style="margin-left: 20px;">
                    <div class="diagram-title">Unmanaged Flow</div>
                    <div class="diagram-box concept-box-alt">Your C++ Code</div>
                    <div class="arrow-down" style="font-size: 61px;">&darr;</div>
                    <div class="diagram-box concept-box-grey">Operating System</div>
                </div>
            </div>
        </div>
        <div class="example">
            <strong>Real-world Example:</strong>
            <ul>
                <li><strong>Managed Code (C#):</strong> It's like driving a modern car with automatic transmission, anti-lock brakes, and airbags. The **CLR** is the car's computer, managing the engine and protecting you. You just steer.</li>
                <li><strong>Unmanaged Code (C++):</strong> It's like riding a powerful, custom-built motorcycle. You have *total* control and it's incredibly fast, but you are responsible for *everything*. If you forget to manage your fuel (memory), you'll crash.</li>
            </ul>
        </div>

        <h3>4. What is the Common Type System (CTS) and how does it support language interoperability?</h3>
        <p>The <strong>Common Type System (CTS)</strong> is a standard set of data types defined by the .NET Framework that all .NET languages must use.</p>
        <p><strong>How it supports interoperability:</strong></p>
        <ul>
            <li>It ensures that all .NET languages "speak the same language" regarding data.</li>
            <li>For example, a C# <code>int</code> and a VB.NET <code>Integer</code> both compile down to the same type in the CLR: <code>System.Int32</code>.</li>
            <li>Because all languages map their types to this common system, it allows a class written in C# to be seamlessly used (or inherited) by a class written in VB.NET, and vice versa.</li>
        </ul>
        <div class="diagram">
            <div class="diagram-title">Common Type System (CTS)</div>
            <div class="flex-container">
                <div class="diagram-box concept-box-alt">C#<br><code>int</code></div>
                <div class="arrow" style="transform: rotate(30deg);">&rarr;</div>
                <div class="diagram-box concept-box-red" style="padding-top: 20px; padding-bottom: 20px;"><strong>CTS</strong><br>(<code>System.Int32</code>)</div>
                <div class="arrow" style="transform: rotate(-30deg);">&larr;</div>
                <div class="diagram-box concept-box-alt">VB.NET<br><code>Integer</code></div>
            </div>
        </div>
        <div class="example">
            <strong>Real-world Example:</strong> The CTS is like a universal power adapter for travel. Your C# code has a European plug (an `int`), and your VB.NET code has an American plug (an `Integer`). The **CTS** acts as the universal socket, defining a standard `System.Int32` plug. Both your plugs fit into the CTS, so they can share power (data) without problems.
        </div>

        <h3>5. Explain Garbage Collection (GC) in .NET.</h3>
        <p><strong>Garbage Collection (GC)</strong> is the automatic memory manager in the CLR. Its job is to find and release memory that is no longer being used by the application.</p>
        <p><strong>How it works (simplified):</strong></p>
        <ol>
            <li>When an object is created, it's placed in a memory area called the "managed heap."</li>
            <li>The GC periodically runs and checks all objects in the heap.</li>
            <li>It identifies which objects are "unreachable" (i.e., no part of the running program still holds a reference to them).</li>
            <li>It releases the memory occupied by these unreachable objects.</li>
            <li>It compacts the remaining objects in memory to avoid fragmentation.</li>
        </ol>
        <div class="diagram">
            <div class="diagram-title">Garbage Collection (GC)</div>
            <div class="diagram-box" style="width: 80%;">
                <strong>Managed Heap (Before GC)</strong>
                <div class="concept-box-alt" style="display: block; margin: 10px;">Object A (Referenced)</div>
                <div class="concept-box-red" style="display: block; margin: 10px;">Object B (Unreferenced)</div>
                <div class="concept-box-alt" style="display: block; margin: 10px;">Object C (Referenced)</div>
            </div>
            <div class="arrow-down" style="font-size: 20px;">&darr; GC Runs &darr;</div>
            <div class="diagram-box" style="width: 80%;">
                <strong>Managed Heap (After GC)</strong>
                <div class="concept-box-alt" style="display: block; margin: 10px;">Object A (Referenced)</div>
                <div class="concept-box-alt" style="display: block; margin: 10px;">Object C (Referenced)</div>
                <div class="concept-box-grey" style="display: block; margin: 10px;">Memory for B is freed.</div>
            </div>
        </div>
        <div class="example">
            <strong>Real-world Example:</strong> The GC is like a self-cleaning kitchen. You (your code) keep grabbing new plates (objects) from the cupboard (heap) and using them. When you're done, you just leave them on the counter. You don't wash them. The **Garbage Collector (GC)** is a robot that periodically comes out, sees which plates you're no longer using (unreferenced), and automatically washes them and puts them back in the cupboard (frees the memory).
        </div>

        <!-- Unit 2: C# Basics & OOP -->
        <h2>Unit 2: C# Basics & OOP</h2>

        <h3>1. List and describe the four main principles of OOP.</h3>
        <ol>
            <li><strong>Encapsulation:</strong> The practice of binding data (fields) and the methods that operate on that data into a single unit (a class). Data is often hidden (made <code>private</code>) and can only be accessed via public methods (getters/setters or properties).</li>
            <li><strong>Inheritance:</strong> A mechanism where a new class (child/derived class) can "inherit" the properties and methods of an existing class (parent/base class). This promotes code reusability.</li>
            <li><strong>Polymorphism:</strong> This means "many forms." It allows objects of different classes to be treated as objects of a common base class. It's often implemented using method overriding (where a child class provides its own version of a parent's method) or method overloading (having multiple methods with the same name but different parameters).</li>
            <li><strong>Abstraction:</strong> Hiding complex implementation details from the user and only showing the essential features. This is achieved using <code>abstract</code> classes and <code>interfaces</code>, which define *what* a class should do, but not *how* it should do it.</li>
        </ol>
        <div class="diagram">
            <div class="diagram-title">Four Principles of OOP</div>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                <div class="diagram-box"><strong>Encapsulation</strong><br>(Hides data in a "capsule")</div>
                <div class="diagram-box"><strong>Abstraction</strong><br>(Hides complex logic)</div>
                <div class="diagram-box"><strong>Inheritance</strong><br>("is-a" relationship, reuses code)</div>
                <div class="diagram-box"><strong>Polymorphism</strong><br>(Same method, different behaviors)</div>
            </div>
        </div>
        <div class="example">
            <strong>Real-world Example:</strong> Imagine a "Car" object.
            <ul>
                <li><strong>Encapsulation:</strong> The engine is hidden under the hood. You don't need to know *how* it works; you just use the pedals and key (public methods) to interact with it.</li>
                <li><strong>Abstraction:</strong> The steering wheel *is* the abstraction. It hides the complex steering rack, hydraulics, and axle logic. You just use the simple interface of "turn wheel."</li>
                <li><strong>Inheritance:</strong> A "SportsCar" *is-a* "Car." It inherits all the "Car" parts (wheels, engine, steering wheel) but adds new ones (a spoiler) or changes existing ones (a bigger engine).</li>
                <li><strong>Polymorphism:</strong> Your "Car" object and your "SportsCar" object both have a `Drive()` method. When you call `Drive()`, the "Car" drives normally, but the "SportsCar" drives fast. Same method name, different behavior.</li>
            </ul>
        </div>

        <h3>2. Differentiate between Value Types and Reference Types.</h3>
        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>Value Types</th>
                    <th>Reference Types</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Storage</strong></td>
                    <td>Stored directly on the <strong>Stack</strong> (for local variables).</td>
                    <td>Stored on the <strong>Heap</strong>. A "pointer" or reference to the heap location is stored on the stack.</td>
                </tr>
                <tr>
                    <td><strong>Copying</strong></td>
                    <td>When copied, the actual value is copied. Creates two independent copies.</td>
                    <td>When copied, only the *reference* is copied. Both variables point to the *same* object in memory.</td>
                </tr>
                <tr>
                    <td><strong>Null?</strong></td>
                    <td>Cannot be null (unless it's a "Nullable" type, e.g., <code>int?</code>).</td>
                    <td>Can be null (meaning it doesn't point to any object).</td>
                </tr>
                <tr>
                    <td><strong>Examples</strong></td>
                    <td><code>int</code>, <code>float</code>, <code>double</code>, <code>bool</code>, <code>char</code>, <code>struct</code>, <code>enum</code></td>
                    <td><code>string</code>, <code>object</code>, <code>class</code>, <code>interface</code>, <code>delegate</code>, <code>array</code></td>
                </tr>
            </tbody>
        </table>
        <div class="diagram">
            <div class="diagram-title">Value Type vs. Reference Type</div>
            <div class="flex-container">
                <div class="diagram-box" style="width: 40%; background-color: #f5f5f5; border-color: #e0e0e0;">
                    <strong>Value Type (e.g., int)</strong>
                    <div class="concept-box" style="display: block; margin-top: 10px; background-color: #fff;"><strong>STACK</strong><br><code>int x = 10;</code></div>
                </div>
                <div class="diagram-box" style="width: 40%; background-color: #f5f5f5; border-color: #e0e0e0;">
                    <strong>Reference Type (e.g., class)</strong>
                    <div class="concept-box" style="display: block; margin-top: 10px; background-color: #fff;"><strong>STACK</strong><br><code>MyClass y = (Address 01)</code></div>
                    <div class="arrow-down">&darr; (Points to)</div>
                    <div class="concept-box concept-box-alt" style="display: block;"><strong>HEAP (Address 01)</strong><br>[Object's Data]</div>
                </div>
            </div>
        </div>
        <div class="example">
            <strong>Real-world Example:</strong>
            <ul>
                <li><strong>Value Type (int):</strong> It's like a *piece of paper* with a number written on it. If you "copy" it for a friend, you write the *same number* on a *new* piece of paper. If your friend changes their paper, yours is unaffected.</li>
                <li><strong>Reference Type (class):</strong> It's like a *Google Doc*. If you "share" it with a friend, you are just sending them a *link* (a reference). You both look at the *same* document. If your friend changes the doc, you see the changes instantly.</li>
            </ul>
        </div>

        <h3>3. What are Boxing and Unboxing in C#? Provide examples.</h3>
        <p>Boxing and Unboxing are processes that bridge the gap between Value Types and Reference Types.</p>
        <ul>
            <li><strong>Boxing (Implicit):</strong> The process of converting a <strong>Value Type</strong> (like <code>int</code>) into a <strong>Reference Type</strong> (like <code>object</code>). The CLR wraps the value inside a new object on the heap.</li>
            <li><strong>Unboxing (Explicit):</strong> The process of extracting the original Value Type from the object it was boxed into. This requires an explicit cast.</li>
        </ul>
        <div class="diagram">
            <div class="diagram-title">Boxing & Unboxing Flow</div>
            <div class="flex-container">
                <div class="flex-column">
                    <div class="diagram-box concept-box-grey"><strong>STACK</strong><br><code>int i = 123;</code></div>
                </div>
                <div class="flex-column" style="margin: 0 10px;">
                    <div class="arrow">&rarr;</div>
                    <div style="font-size: 0.9em;"><strong>Boxing</strong></div>
                    <div style="font-size: 0.9em;">(Value copied to Heap)</div>
                </div>
                <div class="flex-column">
                    <div class="diagram-box concept-box-alt"><strong>HEAP</strong><br>[ object wrapper ]<br>[ value: 123 ]</div>
                    <div class="diagram-box concept-box-grey" style="margin-top: 5px;"><strong>STACK</strong><br><code>object o;</code> (points to Heap)</div>
                </div>
                <div class="flex-column" style="margin: 0 10px;">
                    <div class="arrow">&rarr;</div>
                    <div style="font-size: 0.9em;"><strong>Unboxing</strong></div>
                    <div style="font-size: 0.9em;">(Value copied to Stack)</div>
                </div>
                 <div class="flex-column">
                    <div class="diagram-box concept-box-grey"><strong>STACK</strong><br><code>int j = (int)o;</code></div>
                </div>
            </div>
        </div>
<pre><code class="language-csharp">
// --- Boxing ---
int myValue = 123;
// 'myValue' is a Value Type on the Stack.
object myBoxedValue = myValue; // Implicitly boxed. 
// 'myBoxedValue' is a Reference Type pointing to the value 123 on the Heap.

// --- Unboxing ---
int myUnboxedValue = (int)myBoxedValue; // Explicitly unboxed.
// The value is copied from the heap back to the stack.
</code></pre>
        <div class="example">
            <strong>Real-world Example:</strong> Think of a pet fish (a `Value Type`).
            <ul>
                <li><strong>Boxing:</strong> You need to mail your fish. You take the fish (the value) and put it in a "box" with water (an `object` wrapper) and send it to the post office (the `Heap`). The fish is now an "object."</li>
                <li><strong>Unboxing:</strong> Your friend receives the package. They can't play with the "box." They have to *explicitly* open the box and take the fish *out* of its wrapper. That's unboxing.</li>
            </ul>
        </div>

        <h3>4. Explain Checked and Unchecked blocks for overflow handling.</h3>
        <p>These blocks tell the CLR how to handle "arithmetic overflow," which happens when the result of a math operation is too large for the data type to hold.</p>
        <ul>
            <li><strong><code>checked</code> block:</strong> This block *enforces* overflow checking. If an overflow occurs, a <code>System.OverflowException</code> is thrown. This is safer.</li>
            <li><strong><code>unchecked</code> block:</strong> This block *ignores* overflow. The value will simply "wrap around" (becoming a negative number, usually) and no exception is thrown. This is the default behavior in C# for most operations.</li>
        </ul>
        <div class="diagram">
            <div class="diagram-title">Overflow Handling</div>
            <div class="flex-container">
                <div class="diagram-box" style="width: 40%; background-color: #f5f5f5; border-color: #e0e0e0;">
                    <strong><code>checked { int.MaxValue + 1; }</code></strong>
                    <div class="arrow-down">&darr;</div>
                    <div class="concept-box concept-box-alt">Overflow Occurs?</div>
                    <div class="arrow-down">&darr;</div>
                    <div class="concept-box concept-box-red"><strong>Exception Thrown!</strong><br>(Program stops)</div>
                </div>
                <div class="diagram-box" style="width: 40%; background-color: #f5f5f5; border-color: #e0e0e0;">
                    <strong><code>unchecked { int.MaxValue + 1; }</code></strong>
                    <div class="arrow-down">&darr;</div>
                    <div class="concept-box concept-box-alt">Overflow Occurs?</div>
                    <div class="arrow-down">&darr;</div>
                    <div class="concept-box concept-box-grey"><strong>Value Wraps Around</strong><br>(Becomes negative, no error)</div>
                </div>
            </div>
        </div>
<pre><code class="language-csharp">
int maxInt = int.MaxValue; // 2,147,483,647

try
{
    // This block will throw an exception
    checked
    {
        int overflow = maxInt + 1; 
    }
}
catch (OverflowException ex)
{
    Console.WriteLine("Checked block failed!");
}

// This block will not throw. The value just wraps.
unchecked
{
    int wrap = maxInt + 1; // 'wrap' will be -2,147,483,648
}
</code></pre>
        <div class="example">
            <strong>Real-world Example:</strong> It's like a car's odometer. An `int` can only go up to ~2.1 billion.
            <ul>
                <li><strong><code>unchecked</code> (default):</strong> This is like an old car's odometer. When it hits 999,999, it doesn't break; it just "wraps around" back to 000,000 (or in C#, to the lowest negative number).</li>
                <li><strong><code>checked</code>:</strong> This is like a modern smart-car. If you try to go past the limit, the car's computer (CLR) throws a major error (an `OverflowException`) and stops, saying "This number is too big!"</li>
            </ul>
        </div>

        <h3>5. (CODE) Create a C# class using auto-implemented properties.</h3>
        <p>Auto-implemented properties are a shortcut to create a private backing field and its public <code>get</code> and <code>set</code> accessors in one line.</p>
<pre><code class="language-csharp">
// 1. Define the class with auto-implemented properties
public class Book
{
    public string Title { get; set; }
    public string Author { get; set; }
    public double Price { get; set; }
}

// 2. Use the class
Book myBook = new Book();
myBook.Title = "Fundamentals of Visual Programming";
myBook.Price = 54.99;
Console.WriteLine(myBook.Title); // Prints the title
</code></pre>
        <div class="example">
            <strong>Real-world Example:</strong> This `Book` class is a blueprint for a library's database. The "auto-implemented property" <code>public string Title { get; set; }</code> is like a magic, self-labeling box. You just declare you *want* a box for "Title," and the compiler (C#) automatically builds the private storage for it *and* the public "get" (read the label) and "set" (write a new label) functions for you. It's a huge time-saver.
        </div>

        <!-- Unit 3: Building Desktop Application (Windows Forms) -->
        <h2>Unit 3: Building Desktop Application (Windows Forms)</h2>
        
        <h3>1. Explain the key properties and events of the Button and TextBox controls.</h3>
        <p><strong>TextBox Control:</strong> Allows the user to enter text.</p>
        <ul>
            <li><strong>Properties:</strong> <code>Text</code> (what's in the box), <code>Multiline</code> (true/false), <code>PasswordChar</code> (e.g., '*'), <code>ReadOnly</code> (true/false).</li>
            <li><strong>Events:</strong> <code>TextChanged</code> (fires *every time* the text changes, on each key press).</li>
        </ul>
        <p><strong>Button Control:</strong> A standard button the user can click.</p>
        <ul>
            <li><strong>Properties:</strong> <code>Text</code> (what's written on the button), <code>Enabled</code> (true/false, can it be clicked).</li>
            <li><strong>Events:</strong> <code>Click</code> (the most important event, fires *once* when the user clicks it).</li>
        </ul>
        <div class="diagram">
            <div class="diagram-title">TextBox vs. Button</div>
            <div class="flex-container">
                <div class="diagram-box" style="width: 40%;">
                    <strong>TextBox</strong>
                    <div class="concept-box concept-box-grey">[ <u>Hello|</u> ]</div>
                    <div style="text-align: left; font-size: 0.9em; margin-top: 10px;">
                        <strong>Prop:</strong> <code>Text = "Hello"</code><br>
                        <strong>Event:</strong> <code>TextChanged</code>
                    </div>
                </div>
                <div class="diagram-box" style="width: 40%;">
                    <strong>Button</strong>
                    <div class="concept-box concept-box-grey">[ Submit ]</div>
                    <div style="text-align: left; font-size: 0.9em; margin-top: 10px;">
                        <strong>Prop:</strong> <code>Text = "Submit"</code><br>
                        <strong>Event:</strong> <code>Click</code>
                    </div>
                </div>
            </div>
        </div>
        <div class="example">
            <strong>Real-world Example:</strong> A **TextBox** is like an empty form field on a piece of paper (e.g., "Name: _________"). The `Text` property is what's written on the line. The `TextChanged` event fires *as* you are writing. A **Button** is the "Submit" box at the end of the form. The `Text` property is the "Submit" label. The `Click` event fires *only* when you tap the "Submit" box.
        </div>

        <h3>2. Compare MessageBox and TooltipProvider for user feedback.</h3>
        <table>
            <thead>
                <tr>
                    <th>Feature</th>
                    <th>MessageBox</th>
                    <th>TooltipProvider</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td><strong>Purpose</strong></td>
                    <td>Shows an important message (error, warning, confirmation) in a new pop-up window.</td>
                    <td>Shows a small, helpful hint (a "tooltip") when the user *hovers* over a control.</td>
                </tr>
                <tr>
                    <td><strong>Interaction</strong></td>
                    <td><strong>Modal</strong>. It *stops* the application and forces the user to click a button (OK, Yes, No).</td>
                    <td><strong>Non-intrusive</strong>. It appears/disappears automatically and does *not* stop the application.</td>
                </tr>
                <tr>
                    <td><strong>Use Case</strong></td>
                    <td>"Are you sure you want to delete this?" or "Error: Invalid input."</td>
                    <td>"Enter your name here" (on a TextBox) or "Click to save" (on a Button).</td>
                </tr>
            </tbody>
        </table>
        <div class="diagram">
            <div class="diagram-title">MessageBox vs. Tooltip</div>
            <div class="flex-container">
                <div class="diagram-box" style="width: 40%; background-color: #f5f5f5; border-color: #e0e0e0;">
                    <strong>MessageBox</strong>
                    <div class="concept-box concept-box-red" style="margin-top: 10px; padding: 20px;">
                        [X] Error!<br>Invalid Input.<br><br>[ OK ]
                    </div>
                    <p style="margin-top: 10px;"><strong>Stops everything!</strong> (Modal)</p>
                </div>
                <div class="diagram-box" style="width: 40%; background-color: #f5f5f5; border-color: #e0e0e0;">
                    <strong>Tooltip</strong>
                    <div class="concept-box concept-box-grey" style="margin-top: 10px; padding: 20px;">
                        Name: [ <u>User|</u> ]
                    </div>
                    <div class="concept-box-alt" style="padding: 5px; margin-top: 5px;">
                        Enter your full name
                    </div>
                    <p style="margin-top: 10px;">Just a hint. (Non-intrusive)</p>
                </div>
            </div>
        </div>
        <div class="example">
            <strong>Real-world Example:</strong>
            <ul>
                <li>A <strong>MessageBox</strong> is like a security guard who steps in front of you, stops you, and *forces* you to answer a question ("Are you sure?"). You can't do anything else until you answer.</li>
                <li>A <strong>Tooltip</strong> is like a quiet museum label next to a painting. You can look at it if you're curious (by hovering), but it doesn't stop you from walking around.</li>
            </ul>
        </div>

        <h3>3. What is the role of the ErrorProvider control?</h3>
        <p>The <code>ErrorProvider</code> is a control used for form validation. It provides a non-intrusive way to show that a control has an error, without stopping the user with a <code>MessageBox</code>.</p>
        <p><strong>How it works:</strong></p>
        <ol>
            <li>You add an <code>ErrorProvider</code> control to your form (it sits in the component tray).</li>
            <li>In your code (e.g., a Button's <code>Click</code> event), you check if a control is valid.</li>
            <li>If the control is *invalid* (e.g., a <code>TextBox</code> is empty), you call the <code>ErrorProvider</code>'s <code>SetError()</code> method.</li>
            <li>This displays a small, blinking error icon (e.g., an "!") next to the invalid control.</li>
            <li>When the user hovers over the icon, the error message you provided is shown as a tooltip.</li>
        </ol>
        <div class="diagram">
            <div class="diagram-title">ErrorProvider Flow</div>
            <div class="flex-container">
                <div class="diagram-box">User Clicks "Save"</div>
                <div class="arrow">&rarr;</div>
                <div class="diagram-box concept-box-alt">Code checks:<br><code>if (textBox1.Text == "")</code></div>
                <div class="arrow">&rarr;</div>
                <div class="diagram-box concept-box-red"><code>errorProvider1.SetError(...)</code></div>
                <div class="arrow">&rarr;</div>
                <div class="diagram-box concept-box-grey" style="width: 150px;">Name: [ ] <span style="color: red; font-size: 24px; vertical-align: middle;"><strong>!</strong></span></div>
            </div>
        </div>
<pre><code class="language-csharp">
// Assume connString and query are defined, and dataGridView1 exists on the form

// 1. Define Connection String and Query
string connString = @"Data Source=YourServer;Initial Catalog=YourDatabase;Integrated Security=True";
string query = "SELECT * FROM Employees";

// 2. Create the DataAdapter (Bridge) and DataSet (In-memory copy)
SqlDataAdapter dataAdapter = new SqlDataAdapter(query, connString);
DataSet dataSet = new DataSet();

// 3. Fill the DataSet
// .Fill() automatically opens and closes the connection
dataAdapter.Fill(dataSet, "EmployeesTable"); 

// 4. Bind the in-memory data to the visual DataGridView
dataGridView1.DataSource = dataSet.Tables["EmployeesTable"];

// 5. Good practice to dispose of the adapter
dataAdapter.Dispose();
</code></pre>
        <div class="example">
            <strong>Real-world Example:</strong> This code is for a front-desk receptionist.
            <ul>
                <li>The <strong>`connString`</strong> is the phone number for the main office (database).</li>
                <li>The <strong>`query`</strong> is the question "Can I have the whole employee list?"</li>
                <li>The <strong>`dataAdapter.Fill(dataSet)`</strong> is the receptionist making the call, getting the list, and writing it down on their *own clipboard* (the `DataSet`).</li>
                <li>Finally, <strong>`dataGridView1.DataSource = ...`</strong> is them taking that clipboard and *displaying it on the public-facing monitor* (the `DataGridView`) for everyone to see.</li>
            </ul>
        </div>

    </div>
    <!-- Prism.js JS for syntax highlighting -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
</body>
</html>
