<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GhostShare | Secure Air-Gapped Pairing</title>
    
    <!-- Dependencies (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>

    <style>
        :root {
            --bg: #050505;
            --surface: #121212;
            --border: #333;
            --fg: #e0e0e0;
            --dim: #888;
            --accent: #fff;
            --success: #00e676;
            --error: #ff5252;
            --warning: #ffab00;
            --info: #2979ff;
            --font-mono: 'SF Mono', 'Roboto Mono', monospace;
            --ease: cubic-bezier(0.23, 1, 0.32, 1);
        }

        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: var(--bg); color: var(--fg); font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            font-size: 14px; line-height: 1.5; height: 100vh; display: flex; flex-direction: column; overflow: hidden;
        }

        /* UTILS */
        .container { max-width: 680px; margin: 0 auto; width: 100%; padding: 15px; flex: 1; display: flex; flex-direction: column; position: relative; overflow-y: auto; }
        .flex-row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
        .flex-col { display: flex; flex-direction: column; gap: 10px; }
        .center { text-align: center; justify-content: center; }
        .hidden { display: none !important; }
        .scroll-y { overflow-y: auto; flex: 1; min-height: 0; }
        
        /* TYPOGRAPHY */
        h1 { font-family: var(--font-mono); font-size: 16px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; color: var(--accent); }
        .mono { font-family: var(--font-mono); font-variant-numeric: tabular-nums; }
        .label { font-size: 11px; text-transform: uppercase; color: var(--dim); letter-spacing: 0.5px; font-weight: 600; }

        /* COMPONENTS */
        .card { background: var(--surface); border: 1px solid var(--border); padding: 20px; border-radius: 6px; }
        
        .btn {
            background: var(--fg); color: var(--bg); border: none; padding: 12px; font-weight: 700; font-size: 13px;
            cursor: pointer; width: 100%; text-transform: uppercase; letter-spacing: 0.5px; border-radius: 4px;
            transition: opacity 0.2s;
        }
        .btn:active { opacity: 0.7; }
        .btn:disabled { background: var(--border); color: var(--dim); cursor: not-allowed; opacity: 0.5; }
        .btn.outline { background: transparent; color: var(--fg); border: 1px solid var(--border); }
        .btn.outline:hover { border-color: var(--fg); }
        .btn.danger { background: rgba(255, 82, 82, 0.1); color: var(--error); border: 1px solid var(--error); }
        .btn.info { background: rgba(41, 121, 255, 0.1); color: var(--info); border: 1px solid var(--info); }
        .btn.success { background: var(--success); color: #000; }

        input[type="text"] {
            width: 100%; background: #000; border: 1px solid var(--border); color: var(--accent);
            padding: 15px; font-family: var(--font-mono); font-size: 18px; text-align: center;
            letter-spacing: 3px; text-transform: uppercase; border-radius: 4px; margin-bottom: 10px;
        }
        input[type="text"]:focus { border-color: var(--accent); }

        /* AUDIO VIZ */
        .audio-wave { display: flex; gap: 2px; height: 30px; align-items: center; justify-content: center; margin: 10px 0; }
        .wave-bar { width: 4px; background: var(--info); height: 5px; border-radius: 2px; animation: wave 0.5s infinite ease-in-out; }
        .wave-bar:nth-child(odd) { animation-duration: 0.6s; }
        @keyframes wave { 0%, 100% { height: 5px; opacity: 0.5; } 50% { height: 25px; opacity: 1; } }
        
        /* STATUS */
        .status-pill { padding: 4px 10px; border-radius: 100px; font-size: 10px; font-weight: 700; text-transform: uppercase; background: var(--border); color: var(--dim); display: flex; align-items: center; gap: 6px; }
        .status-pill.secure { background: rgba(0, 230, 118, 0.1); color: var(--success); border: 1px solid var(--success); }
        .status-pill.warn { background: rgba(255, 171, 0, 0.1); color: var(--warning); border: 1px solid var(--warning); }
        .dot { width: 6px; height: 6px; border-radius: 50%; background: currentColor; }
        .dot.pulse { animation: blink 1.5s infinite; }
        @keyframes blink { 0% { opacity: 0.4; } 50% { opacity: 1; } 100% { opacity: 0.4; } }

        /* MODALS */
        .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.95); z-index: 999; display: flex; align-items: center; justify-content: center; opacity: 0; pointer-events: none; transition: 0.2s; }
        .overlay.active { opacity: 1; pointer-events: all; }
        .modal { background: var(--surface); border: 1px solid var(--border); padding: 25px; width: 90%; max-width: 400px; border-radius: 8px; text-align: center; }

        /* TRANSFER UI */
        .transfer-row { background: var(--bg); border: 1px solid var(--border); padding: 12px; margin-bottom: 8px; border-radius: 4px; }
        .progress-bg { background: var(--border); height: 4px; width: 100%; border-radius: 2px; margin: 8px 0; overflow: hidden; }
        .progress-fill { background: var(--success); height: 100%; width: 0%; transition: width 0.2s linear; }

        /* TABS */
        .tabs { display: flex; border-bottom: 1px solid var(--border); margin-bottom: 20px; }
        .tab { flex: 1; padding: 10px; text-align: center; cursor: pointer; color: var(--dim); border-bottom: 2px solid transparent; font-size: 12px; font-weight: 600; text-transform: uppercase; }
        .tab.active { color: var(--accent); border-color: var(--accent); }

        #drag-target { position: fixed; inset: 0; background: rgba(0,0,0,0.9); border: 4px dashed var(--accent); z-index: 2000; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: 700; color: var(--accent); opacity: 0; pointer-events: none; transition: 0.2s; }
        #drag-target.active { opacity: 1; pointer-events: all; }
        
        #toast { position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%); background: var(--accent); color: #000; padding: 10px 20px; border-radius: 4px; font-weight: 700; font-size: 12px; opacity: 0; pointer-events: none; transition: 0.3s; z-index: 3000; box-shadow: 0 5px 15px rgba(0,0,0,0.5); }
        #toast.show { opacity: 1; transform: translateX(-50%) translateY(0); }
    </style>
</head>
<body>

    <div id="drag-target">DROP FILES TO SEND</div>
    <div id="toast">Notification</div>

    <!-- MODAL: INCOMING BUNDLE -->
    <div id="modal-bundle" class="overlay">
        <div class="modal">
            <h2 style="margin-bottom: 10px;">INCOMING FILES</h2>
            <div id="bundle-list" style="max-height: 150px; overflow-y: auto; text-align: left; font-size: 12px; margin: 15px 0; border: 1px solid var(--border); padding: 10px;"></div>
            <div class="flex-col">
                <button class="btn success" onclick="app.acceptBundle(true)">Download ZIP</button>
                <button class="btn outline" onclick="app.acceptBundle(false)">Download Individual</button>
                <button class="btn danger" onclick="app.rejectBundle()">Reject</button>
            </div>
        </div>
    </div>

    <!-- HEADER -->
    <div style="padding: 15px; border-bottom: 1px solid var(--border); background: var(--bg);">
        <div class="flex-row" style="max-width: 680px; margin: 0 auto;">
            <div class="flex-col" style="gap: 0;">
                <h1>GHOSTSHARE</h1>
                <span class="label">SECURE AIR-GAPPED PAIRING</span>
            </div>
            <div id="status-pill" class="status-pill">
                <div class="dot"></div> <span id="status-text">DISCONNECTED</span>
            </div>
        </div>
    </div>

    <div class="container">
        
        <!-- VIEW: DISCONNECTED -->
        <div id="view-setup" class="flex-col">
            
            <!-- IDENTITY CARD -->
            <div class="card center">
                <span class="label">YOUR SESSION ID</span>
                <div id="my-id" class="mono" style="font-size: 36px; margin: 15px 0; color: var(--accent); letter-spacing: 4px; font-weight: 700;">...</div>
                <div class="flex-row">
                    <button class="btn outline" onclick="app.copyId()">Copy</button>
                    <button class="btn outline" onclick="document.getElementById('qr-box').classList.toggle('hidden')">QR</button>
                </div>
                <div id="qr-box" class="hidden center" style="margin-top: 15px; background: #fff; padding: 10px; border-radius: 4px; display: inline-block;">
                    <div id="qr-target"></div>
                </div>
            </div>

            <!-- PAIRING CARD -->
            <div class="card">
                <div class="tabs">
                    <div class="tab active" onclick="app.switchTab('audio')" id="tab-audio">Audio Pairing</div>
                    <div class="tab" onclick="app.switchTab('manual')" id="tab-manual">Manual / Camera</div>
                </div>

                <!-- TAB: AUDIO -->
                <div id="panel-audio" class="center">
                    <p style="color: var(--dim); margin-bottom: 20px; font-size: 13px;">
                        Place devices near each other. One broadcasts, the other detects.
                    </p>

                    <div id="audio-controls" class="flex-col">
                        <button class="btn info" onclick="app.startBroadcast()">
                            ðŸ”Š Broadcast Signal
                        </button>
                        <button class="btn outline" onclick="app.startDetect()">
                            ðŸŽ¤ Detect Nearby Device
                        </button>
                    </div>

                    <!-- BROADCASTING STATE -->
                    <div id="state-broadcasting" class="hidden">
                        <div class="audio-wave">
                            <div class="wave-bar"></div><div class="wave-bar"></div><div class="wave-bar"></div><div class="wave-bar"></div><div class="wave-bar"></div>
                        </div>
                        <p class="mono" style="color: var(--info); font-size: 12px;">EMITTING SIGNAL...</p>
                        <button class="btn outline" style="margin-top: 10px;" onclick="app.stopAudio()">Stop</button>
                    </div>

                    <!-- DETECTING STATE -->
                    <div id="state-detecting" class="hidden">
                        <div class="audio-wave">
                            <div class="wave-bar" style="background: var(--success)"></div>
                            <div class="wave-bar" style="background: var(--success)"></div>
                            <div class="wave-bar" style="background: var(--success)"></div>
                        </div>
                        <p class="mono" style="color: var(--success); font-size: 12px;">LISTENING...</p>
                        <button class="btn outline" style="margin-top: 10px;" onclick="app.stopAudio()">Cancel</button>
                    </div>
                </div>

                <!-- TAB: MANUAL -->
                <div id="panel-manual" class="hidden">
                    <div id="scanner-wrap" class="hidden" style="margin-bottom: 15px; border: 1px solid var(--border); height: 200px; overflow: hidden;">
                        <div id="reader"></div>
                    </div>
                    <input type="text" id="peer-input" placeholder="ENTER ID" maxlength="8">
                    <div class="flex-row">
                        <button class="btn" onclick="app.connectManual()">Connect</button>
                        <button class="btn outline" style="width: auto;" onclick="app.toggleScanner()">ðŸ“·</button>
                    </div>
                </div>
            </div>
        </div>

        <!-- VIEW: CONNECTED -->
        <div id="view-workspace" class="hidden flex-col">
            <div class="card flex-row" style="padding: 15px;">
                <div class="flex-col" style="gap: 2px;">
                    <span class="label" style="color: var(--success);">SECURE CHANNEL</span>
                    <span style="font-size: 11px; color: var(--dim);">ECDH Encrypted â€¢ Verified</span>
                </div>
                <button class="btn danger" style="width: auto; padding: 8px 15px;" onclick="app.disconnect()">Disconnect</button>
            </div>

            <div class="card center" 
                 style="border: 2px dashed var(--border); padding: 40px; cursor: pointer; transition: 0.2s;"
                 onclick="document.getElementById('file-input').click()"
                 onmouseover="this.style.borderColor='var(--accent)'"
                 onmouseout="this.style.borderColor='var(--border)'">
                <div style="font-size: 24px; margin-bottom: 10px;">ðŸ“‚</div>
                <div style="font-weight: 700;">CLICK TO UPLOAD</div>
                <div style="font-size: 12px; color: var(--dim);">or drag files here</div>
                <input type="file" id="file-input" multiple style="display: none;" onchange="app.handleFiles(this.files)">
            </div>

            <div id="transfers" class="flex-col scroll-y"></div>
        </div>
    </div>

<script>
/**
 * GHOSTSHARE v6.0 - FINAL PRODUCTION BUILD
 * Features:
 * - WebRTC (PeerJS) with ECDH+HMAC Mutual Auth
 * - Audio-based Pairing (FSK Modem) for Discovery
 * - Bundle Transfer with ZIP Support
 * - Backpressure & Memory Management
 */

// --- CONSTANTS ---
const CONFIG = {
    // WebRTC
    ICE: [{ urls: 'stun:stun.l.google.com:19302' }],
    // Transfer
    CHUNK_START: 16384,
    CHUNK_MAX: 262144,
    BUFFER_CAP: 8 * 1024 * 1024, // 8MB Backpressure limit
    MAX_BUNDLE_MEM: 500 * 1024 * 1024, // 500MB Max for ZIP
    // Audio FSK (Frequency Shift Keying) for Hex ID
    AUDIO: {
        FREQ_START: 17500, // Start Sentinel
        FREQ_BASE: 17800,  // Data 0
        STEP: 100,         // 100Hz separation
        DURATION: 0.25,    // 250ms per tone
        FREQ_END: 19500    // End Sentinel
    }
};

// --- UTILS: CRYPTO ---
const Crypto = {
    async genKey() { return window.crypto.subtle.generateKey({name:"ECDH", namedCurve:"P-256"}, true, ["deriveBits"]); },
    async expKey(k) { return window.crypto.subtle.exportKey("jwk", k); },
    async impKey(j) { return window.crypto.subtle.importKey("jwk", j, {name:"ECDH", namedCurve:"P-256"}, true, []); },
    async derive(priv, pub) { 
        const bits = await window.crypto.subtle.deriveBits({name:"ECDH", public:pub}, priv, 256);
        return window.crypto.subtle.importKey("raw", bits, {name:"HMAC", hash:"SHA-256"}, false, ["sign","verify"]);
    },
    async sign(k, d) { return window.crypto.subtle.sign("HMAC", k, d); },
    async verify(k, s, d) { return window.crypto.subtle.verify("HMAC", k, s, d); },
    rand(len) { return window.crypto.getRandomValues(new Uint8Array(len)); }
};

// --- UTILS: ZIP WRITER (Store Only) ---
class ZipBuilder {
    constructor() { this.files=[]; this.crcT=new Uint32Array(256); for(let n=0;n<256;n++){let c=n;for(let k=0;k<8;k++)c=((c&1)?(0xEDB88320^(c>>>1)):(c>>>1));this.crcT[n]=c;} }
    crc32(d) { let c=0^(-1); for(let i=0;i<d.length;i++) c=(c>>>8)^this.crcT[(c^d[i])&0xFF]; return (c^(-1))>>>0; }
    add(n, d) { this.files.push({n, d}); }
    build() {
        const parts=[]; let off=0; const cd=[];
        for(const f of this.files) {
            const nb=new TextEncoder().encode(f.n); const d=new Uint8Array(f.d); const crc=this.crc32(d); const sz=d.length;
            const h=new Uint8Array(30+nb.length); const v=new DataView(h.buffer);
            v.setUint32(0,0x04034b50,true); v.setUint16(4,10,true); v.setUint32(14,crc,true); v.setUint32(18,sz,true); v.setUint32(22,sz,true); v.setUint16(26,nb.length,true);
            h.set(nb,30); parts.push(h); parts.push(d);
            cd.push({nb,crc,sz,off}); off+=h.length+sz;
        }
        const ds=off;
        for(const c of cd) {
            const h=new Uint8Array(46+c.nb.length); const v=new DataView(h.buffer);
            v.setUint32(0,0x02014b50,true); v.setUint16(4,10,true); v.setUint16(6,10,true); v.setUint32(16,c.crc,true); v.setUint32(20,c.sz,true); v.setUint32(24,c.sz,true); v.setUint16(28,c.nb.length,true); v.setUint32(42,c.off,true);
            h.set(c.nb,46); parts.push(h); off+=h.length;
        }
        const e=new Uint8Array(22); const ev=new DataView(e.buffer);
        ev.setUint32(0,0x06054b50,true); ev.setUint16(8,this.files.length,true); ev.setUint16(10,this.files.length,true); ev.setUint32(12,off-ds,true); ev.setUint32(16,ds,true);
        parts.push(e); return new Blob(parts,{type:'application/zip'});
    }
}

// --- AUDIO MODEM (FSK) ---
class AudioModem {
    constructor() { this.ctx = null; this.osc = null; this.timer = null; }
    
    async init() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        if (this.ctx.state === 'suspended') await this.ctx.resume();
    }

    stop() {
        if(this.osc) { this.osc.stop(); this.osc.disconnect(); this.osc=null; }
        if(this.timer) { clearTimeout(this.timer); this.timer=null; }
        if(this.stream) { this.stream.getTracks().forEach(t=>t.stop()); this.stream=null; }
    }

    // TRANSMIT: ID (Hex) -> Audio
    broadcast(idHex) {
        this.stop();
        const seq = [CONFIG.AUDIO.FREQ_START]; // Start
        for(let char of idHex) {
            const val = parseInt(char, 16);
            seq.push(CONFIG.AUDIO.FREQ_BASE + (val * CONFIG.AUDIO.STEP));
        }
        seq.push(CONFIG.AUDIO.FREQ_END); // End
        
        let idx = 0;
        const playNext = () => {
            if(idx >= seq.length) { idx=0; setTimeout(playNext, 1000); return; } // Loop with pause
            const freq = seq[idx++];
            
            this.osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            this.osc.frequency.value = freq;
            this.osc.connect(gain); gain.connect(this.ctx.destination);
            
            // Envelope
            const now = this.ctx.currentTime;
            gain.gain.setValueAtTime(0, now);
            gain.gain.linearRampToValueAtTime(0.5, now + 0.05);
            gain.gain.setValueAtTime(0.5, now + CONFIG.AUDIO.DURATION - 0.05);
            gain.gain.linearRampToValueAtTime(0, now + CONFIG.AUDIO.DURATION);
            
            this.osc.start(now);
            this.osc.stop(now + CONFIG.AUDIO.DURATION);
            
            this.timer = setTimeout(playNext, CONFIG.AUDIO.DURATION * 1000);
        };
        playNext();
    }

    // RECEIVE: Audio -> ID
    async listen(onFound) {
        this.stop();
        const stream = await navigator.mediaDevices.getUserMedia({audio:{echoCancellation:false,noiseSuppression:false}});
        this.stream = stream;
        const src = this.ctx.createMediaStreamSource(stream);
        const anal = this.ctx.createAnalyser();
        anal.fftSize = 2048; 
        src.connect(anal);
        
        const buf = new Float32Array(anal.frequencyBinCount);
        const nyquist = this.ctx.sampleRate / 2;
        let sequence = [];
        let lastFreq = 0;

        const check = () => {
            if(!this.stream) return;
            anal.getFloatFrequencyData(buf);
            
            // Find Peak in Ultrasonic Range
            let maxDb = -Infinity; let peakF = 0;
            const startBin = Math.floor(17000 / nyquist * buf.length);
            
            for(let i=startBin; i<buf.length; i++) {
                if(buf[i] > maxDb) { maxDb = buf[i]; peakF = i * nyquist / buf.length; }
            }

            if(maxDb > -60) { // Threshold
                // Quantize to nearest bin
                if(Math.abs(peakF - CONFIG.AUDIO.FREQ_START) < 50) {
                    sequence = []; // Reset on Start
                } else if (Math.abs(peakF - CONFIG.AUDIO.FREQ_END) < 50) {
                    if(sequence.length === 6) { // Verify Length
                        // Convert Freqs to Hex
                        let id = "";
                        for(let f of sequence) {
                            const val = Math.round((f - CONFIG.AUDIO.FREQ_BASE) / CONFIG.AUDIO.STEP);
                            if(val >= 0 && val <= 15) id += val.toString(16).toUpperCase();
                        }
                        if(id.length === 6) { onFound(id); return; }
                    }
                    sequence = [];
                } else {
                    // Data Tone logic: Debounce
                    if(Math.abs(peakF - lastFreq) > 40) {
                        sequence.push(peakF);
                        lastFreq = peakF;
                    }
                }
            } else {
                lastFreq = 0; // Silence resets debounce
            }
            requestAnimationFrame(check);
        };
        check();
    }
}

// --- MAIN APP ---
class GhostShare {
    constructor() {
        this.state = 'INIT';
        this.myId = this.genId();
        this.peer = null; this.conn = null;
        this.modem = new AudioModem();
        
        // Crypto State
        this.kp = null; this.key = null; this.nonce = null;
        
        // Transfer State
        this.transfers = {}; this.queue = []; this.bundle = null;

        // UI Refs
        this.ui = {
            id: document.getElementById('my-id'),
            viewSetup: document.getElementById('view-setup'),
            viewWork: document.getElementById('view-workspace'),
            statusText: document.getElementById('status-text'),
            statusPill: document.getElementById('status-pill'),
            transfers: document.getElementById('transfers'),
            toast: document.getElementById('toast'),
            panelAudio: document.getElementById('panel-audio'),
            panelManual: document.getElementById('panel-manual'),
            stateBroad: document.getElementById('state-broadcasting'),
            stateDetect: document.getElementById('state-detecting'),
            btns: document.getElementById('audio-controls')
        };
        
        this.ui.id.innerText = this.myId;
        this.init();
        this.setupDrag();
    }

    genId() { 
        const b = new Uint8Array(3); window.crypto.getRandomValues(b);
        return Array.from(b, x=>x.toString(16).padStart(2,'0')).join('').toUpperCase();
    }

    async init() {
        this.genQr();
        const peerId = new URLSearchParams(location.search).get('peer');
        if(peerId) document.getElementById('peer-input').value = peerId;

        this.peer = new Peer(this.myId, {config: {iceServers: CONFIG.ICE}, debug: 1});
        this.peer.on('open', () => this.setState('READY'));
        this.peer.on('connection', c => this.handleInc(c));
        this.peer.on('error', e => { this.toast(e.type); if(e.type==='peer-unavailable') this.reset(); });
    }

    // --- CONNECTION ---
    connectManual() {
        const id = document.getElementById('peer-input').value.trim().toUpperCase();
        if(id.length !== 6 || id === this.myId) return this.toast('Invalid ID');
        this.connect(id);
    }

    connect(id) {
        this.setState('CONNECTING');
        const c = this.peer.connect(id, {reliable:true});
        this.setupConn(c);
    }

    handleInc(c) {
        // GLARE HANDLING: Lexicographical Tie-Breaker
        if(this.state === 'CONNECTING' || this.state === 'HANDSHAKING') {
            if(this.myId > c.peer) { c.close(); return; } // I win, keep outgoing
            if(this.conn) this.conn.close(); // I lose, accept incoming
        }
        if(this.state === 'SECURE') { c.close(); return; }
        
        this.setState('CONNECTING');
        this.setupConn(c);
    }

    setupConn(c) {
        this.conn = c;
        c.on('open', async () => {
            this.setState('HANDSHAKING');
            // 1. ECDH Start
            this.kp = await Crypto.genKey();
            const exp = await Crypto.expKey(this.kp.publicKey);
            c.send({t:'HS_KEY', k:exp});
        });
        c.on('data', d => this.handleData(d));
        c.on('close', () => this.reset());
        c.on('error', () => this.reset());
    }

    async handleData(d) {
        try {
            switch(d.t) {
                // SECURITY HANDSHAKE
                case 'HS_KEY':
                    if(this.state!=='HANDSHAKING') return;
                    const pub = await Crypto.impKey(d.k);
                    this.key = await Crypto.derive(this.kp.privateKey, pub);
                    this.nonce = Crypto.rand(32);
                    this.conn.send({t:'HS_NONCE', n:Array.from(this.nonce)});
                    break;
                case 'HS_NONCE':
                    // Sign: MyNonce + PeerNonce + MyID + PeerID (Binds session context)
                    const payload = new Uint8Array([...d.n, ...this.nonce, ...new TextEncoder().encode(this.myId + this.conn.peer)]);
                    const sig = await Crypto.sign(this.key, payload);
                    this.conn.send({t:'HS_SIG', s:Array.from(new Uint8Array(sig))});
                    break;
                case 'HS_SIG':
                    const verifyPayload = new Uint8Array([...this.nonce, ...d.n, ...new TextEncoder().encode(this.conn.peer + this.myId)]); // Note ID order flip for verify
                    const valid = await Crypto.verify(this.key, new Uint8Array(d.s), verifyPayload);
                    if(valid) {
                        this.setState('SECURE');
                        this.stopAudio(); // Cleanup audio if used
                    } else {
                        this.toast('Security Check Failed');
                        this.disconnect();
                    }
                    break;
                
                // TRANSFER LOGIC
                case 'OFFER': if(this.state==='SECURE') this.handleOffer(d); break;
                case 'ACCEPT': if(this.state==='SECURE') this.startQueue(); break;
                case 'REJECT': this.toast('Rejected'); this.queue=[]; break;
                case 'META': if(this.state==='SECURE') this.prepDown(d); break;
                case 'CHUNK': if(this.state==='SECURE') this.handleChunk(d); break;
                case 'ACK': if(this.state==='SECURE') this.finTransfer(d.id); break;
            }
        } catch(e) { console.error(e); this.disconnect(); }
    }

    // --- AUDIO PAIRING ---
    switchTab(t) {
        document.querySelectorAll('.tab').forEach(el=>el.classList.remove('active'));
        document.getElementById(`tab-${t}`).classList.add('active');
        document.getElementById('panel-audio').classList.add('hidden');
        document.getElementById('panel-manual').classList.add('hidden');
        document.getElementById(`panel-${t}`).classList.remove('hidden');
    }

    async startBroadcast() {
        try {
            await this.modem.init();
            this.ui.btns.classList.add('hidden');
            this.ui.stateBroad.classList.remove('hidden');
            this.modem.broadcast(this.myId);
        } catch(e) { this.toast('Audio Init Failed'); }
    }

    async startDetect() {
        try {
            await this.modem.init();
            this.ui.btns.classList.add('hidden');
            this.ui.stateDetect.classList.remove('hidden');
            this.modem.listen((id) => {
                this.toast(`Detected: ${id}`);
                this.stopAudio();
                this.connect(id);
            });
        } catch(e) { 
            this.toast('Microphone Blocked'); 
            this.stopAudio();
        }
    }

    stopAudio() {
        this.modem.stop();
        this.ui.stateBroad.classList.add('hidden');
        this.ui.stateDetect.classList.add('hidden');
        this.ui.btns.classList.remove('hidden');
    }

    // --- FILE TRANSFER ---
    handleFiles(files) {
        if(this.state!=='SECURE' || !files.length) return;
        const list = Array.from(files);
        // Mem check for ZIP
        const total = list.reduce((a,b)=>a+b.size,0);
        
        const bid = Math.random().toString(36).slice(2);
        const metas = list.map(f => ({
            name:f.name, size:f.size, type:f.type, 
            id: bid+'_'+Math.random().toString(36).slice(2)
        }));
        
        this.queue = list.map((f,i) => ({f, meta:metas[i]}));
        this.conn.send({t:'OFFER', files: metas, total});
        this.toast('Offer Sent...');
    }

    handleOffer(d) {
        this.bundle = { id: d.id, files: d.files, total: d.total };
        const list = document.getElementById('bundle-list');
        list.innerHTML = d.files.map(f => `<div class="file-entry flex-row"><span>${f.name}</span><span>${this.fmtBytes(f.size)}</span></div>`).join('');
        document.getElementById('modal-bundle').classList.add('active');
    }

    acceptBundle(zip) {
        document.getElementById('modal-bundle').classList.remove('active');
        if(zip && this.bundle.total > CONFIG.MAX_BUNDLE_MEM) {
            this.toast('Too Large for ZIP (Max 500MB)');
            zip = false;
        }
        this.bundle.zip = zip;
        this.bundle.parts = [];
        this.bundle.prog = 0;
        this.conn.send({t:'ACCEPT'});
    }

    rejectBundle() {
        document.getElementById('modal-bundle').classList.remove('active');
        this.conn.send({t:'REJECT'});
    }

    startQueue() {
        if(!this.queue.length) { this.toast('All Sent'); return; }
        const item = this.queue.shift();
        this.send(item);
    }

    send(item) {
        const {f, meta} = item;
        this.transfers[meta.id] = { role:'send', size:f.size, prog:0, status:'SENDING', cs:CONFIG.CHUNK_START };
        this.uiTransfer(meta.id, f.name, 'UPLOAD');
        
        this.conn.send({t:'META', ...meta});
        
        const r = new FileReader();
        let off = 0;
        const t = this.transfers[meta.id];

        const pump = () => {
            if(t.status!=='SENDING' || !this.conn.open) return;
            // Backpressure
            if(this.conn.dataChannel.bufferedAmount > CONFIG.BUFFER_CAP) {
                // Wait for buffer to drain
                const wait = () => {
                    if(this.conn.dataChannel.bufferedAmount < CONFIG.BUFFER_CAP/2) pump();
                    else setTimeout(wait, 50);
                };
                wait();
                return;
            }

            const chunk = f.slice(off, off+t.cs);
            r.readAsArrayBuffer(chunk);
        };

        r.onload = e => {
            this.conn.send({t:'CHUNK', id:meta.id, d:e.target.result});
            off += e.target.result.byteLength;
            t.prog = off;
            this.uiUpdate(meta.id, t.prog, t.size);
            
            if(off < f.size) {
                // Adaptive Chunking
                if(this.conn.dataChannel.bufferedAmount < CONFIG.CHUNK_START) t.cs = Math.min(t.cs*2, CONFIG.CHUNK_MAX);
                pump();
            } else {
                t.status = 'WAIT';
            }
        };
        pump();
    }

    prepDown(d) {
        this.transfers[d.id] = { role:'recv', size:d.size, name:d.name, type:d.type, chunks:[], prog:0, status:'RECV' };
        this.uiTransfer(d.id, d.name, 'DOWNLOAD');
    }

    handleChunk(d) {
        const t = this.transfers[d.id];
        if(!t) return;
        t.chunks.push(d.d);
        t.prog += d.d.byteLength;
        this.uiUpdate(d.id, t.prog, t.size);
        
        if(t.prog >= t.size) {
            // Finish File
            const blob = new Blob(t.chunks, {type:t.type});
            t.chunks = []; // Clear RAM
            t.status = 'DONE';
            this.uiDone(d.id);
            this.conn.send({t:'ACK', id:d.id});

            if(this.bundle && this.bundle.zip) {
                this.bundle.parts.push({n:t.name, d:blob}); // Must await arrayBuffer if using ZipBuilder, simpler here to buffer blob
            } else {
                this.save(blob, t.name);
            }

            // Check Bundle Finish
            if(this.bundle && this.bundle.parts && this.bundle.parts.length === this.bundle.files.length) {
                this.finishZip();
            }
        }
    }

    async finishZip() {
        this.toast('Zipping...');
        const z = new ZipBuilder();
        for(const p of this.bundle.parts) {
            z.add(p.n, await p.d.arrayBuffer());
        }
        this.save(z.build(), `ghostshare_${Date.now()}.zip`);
        this.bundle = null;
    }

    finTransfer(id) {
        const t = this.transfers[id];
        if(t) { t.status = 'DONE'; this.uiDone(id); this.startQueue(); }
    }

    // --- UI HELPERS ---
    setState(s) {
        this.state = s;
        this.ui.statusText.innerText = s;
        this.ui.statusPill.className = 'status-pill';
        
        if(s === 'SECURE') {
            this.ui.viewSetup.classList.add('hidden');
            this.ui.viewWork.classList.remove('hidden');
            this.ui.statusPill.classList.add('secure');
        } else if(s === 'HANDSHAKING' || s === 'CONNECTING') {
            this.ui.statusPill.classList.add('warn');
            this.ui.statusPill.querySelector('.dot').classList.add('pulse');
        } else {
            this.ui.viewSetup.classList.remove('hidden');
            this.ui.viewWork.classList.add('hidden');
            this.ui.statusPill.querySelector('.dot').classList.remove('pulse');
        }
    }

    uiTransfer(id, name, type) {
        const el = document.createElement('div'); el.className = 'transfer-row'; el.id = `ui-${id}`;
        el.innerHTML = `<div class="flex-row"><span class="label">${type}</span><span style="font-size:12px">${name}</span></div><div class="progress-bg"><div class="progress-fill" id="bar-${id}"></div></div>`;
        this.ui.transfers.prepend(el);
    }
    uiUpdate(id, curr, total) { document.getElementById(`bar-${id}`).style.width = `${(curr/total)*100}%`; }
    uiDone(id) { document.getElementById(`bar-${id}`).style.background = 'var(--info)'; }
    
    save(b, n) { const u = URL.createObjectURL(b); const a = document.createElement('a'); a.href=u; a.download=n; document.body.appendChild(a); a.click(); setTimeout(()=>URL.revokeObjectURL(u),60000); }
    
    genQr() { const el=document.getElementById('qr-target'); el.innerHTML=''; new QRCode(el, {text:`${location.href.split('?')[0]}?peer=${this.myId}`, width:128, height:128}); }
    copyId() { navigator.clipboard.writeText(this.myId); this.toast('Copied'); }
    toast(m) { const t=this.ui.toast; t.innerText=m; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),3000); }
    fmtBytes(b) { if(b===0)return'0B'; const i=Math.floor(Math.log(b)/Math.log(1024)); return parseFloat((b/Math.pow(1024,i)).toFixed(2))+['B','KB','MB','GB'][i]; }
    disconnect() { if(this.conn)this.conn.close(); if(this.peer)this.peer.destroy(); location.reload(); }
    reset() { this.disconnect(); }

    toggleScanner() {
        const wrap = document.getElementById('scanner-wrap');
        wrap.classList.toggle('hidden');
        if(!wrap.classList.contains('hidden')) {
            this.scanner = new Html5Qrcode("reader");
            this.scanner.start({facingMode:"environment"}, {fps:10, qrbox:200}, (d)=>{
                const id = new URL(d).searchParams.get('peer') || d;
                if(id){ document.getElementById('peer-input').value=id; this.toggleScanner(); this.connectManual(); }
            });
        } else if(this.scanner) { this.scanner.stop(); this.scanner=null; }
    }
    
    setupDrag() {
        const t = document.getElementById('drag-target');
        window.ondragover = e => { e.preventDefault(); if(this.state==='SECURE') t.classList.add('active'); };
        window.ondragleave = e => { if(e.target===t) t.classList.remove('active'); };
        window.ondrop = e => { e.preventDefault(); t.classList.remove('active'); if(this.state==='SECURE') this.handleFiles(e.dataTransfer.files); };
    }
}

window.app = new GhostShare();
window.onbeforeunload = () => window.app.state === 'SECURE' ? "Active Session" : undefined;
</script>
</body>
</html>


