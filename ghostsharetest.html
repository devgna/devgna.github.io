<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GhostShare | Secure P2P Workspace</title>
    
    <!-- Dependencies (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>

    <style>
        :root {
            --bg: #050505;
            --surface: #111111;
            --border: #333333;
            --fg: #e0e0e0;
            --dim: #888888;
            --accent: #ffffff;
            --success: #4caf50;
            --error: #f44336;
            --warning: #ff9800;
            --font-stack: 'SF Mono', 'Segoe UI Mono', 'Roboto Mono', Menlo, monospace;
            --ease: cubic-bezier(0.23, 1, 0.32, 1);
        }

        /* RESET & BASE */
        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-stack);
            font-size: 13px;
            line-height: 1.5;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
            user-select: none;
        }

        /* UTILS */
        .container { max-width: 680px; margin: 0 auto; width: 100%; padding: 15px; flex: 1; display: flex; flex-direction: column; position: relative; }
        .flex-row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
        .flex-col { display: flex; flex-direction: column; gap: 10px; }
        .center { text-align: center; justify-content: center; }
        .hidden { display: none !important; }
        .scroll-y { overflow-y: auto; flex: 1; }
        
        /* TYPOGRAPHY */
        h1 { font-size: 16px; font-weight: 700; letter-spacing: 1px; text-transform: uppercase; border-bottom: 1px solid var(--border); padding-bottom: 15px; margin-bottom: 20px; color: var(--accent); }
        h2 { font-size: 13px; font-weight: 600; color: var(--dim); text-transform: uppercase; letter-spacing: 1px; margin: 0; }
        p { color: var(--dim); margin-bottom: 10px; }
        .mono-stat { font-variant-numeric: tabular-nums; letter-spacing: -0.5px; }

        /* COMPONENTS */
        .card {
            border: 1px solid var(--border);
            background: var(--surface);
            padding: 20px;
            margin-bottom: 15px;
            border-radius: 4px;
        }

        .btn {
            background: var(--fg);
            color: var(--bg);
            border: 1px solid var(--fg);
            padding: 12px;
            font-family: var(--font-stack);
            font-weight: 700;
            font-size: 12px;
            cursor: pointer;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-radius: 2px;
            transition: all 0.2s;
        }
        .btn:disabled { background: var(--border); border-color: var(--border); color: var(--dim); cursor: not-allowed; opacity: 0.7; }
        .btn.outline { background: transparent; color: var(--fg); }
        .btn.outline:hover { background: rgba(255,255,255,0.05); }
        .btn.danger { border-color: var(--error); color: var(--error); background: transparent; }
        .btn.danger:hover { background: rgba(244, 67, 54, 0.1); }
        .btn.success { border-color: var(--success); background: var(--success); color: white; }

        /* PULSING ANIMATION FOR LISTENER */
        @keyframes pulse-border {
            0% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0.4); border-color: var(--success); color: var(--success); }
            70% { box-shadow: 0 0 0 10px rgba(76, 175, 80, 0); border-color: var(--success); color: var(--success); }
            100% { box-shadow: 0 0 0 0 rgba(76, 175, 80, 0); border-color: var(--success); color: var(--success); }
        }
        .btn.listening { animation: pulse-border 1.5s infinite; background: rgba(76, 175, 80, 0.1); }

        input[type="text"] {
            width: 100%; background: #000; border: 1px solid var(--border); color: var(--accent);
            padding: 15px; font-family: var(--font-stack); font-size: 16px; text-align: center;
            letter-spacing: 3px; text-transform: uppercase; margin-bottom: 10px; border-radius: 2px;
        }
        input[type="text"]:focus { border-color: var(--accent); }

        /* STATUS BADGE */
        .status-badge { 
            padding: 4px 8px; font-size: 10px; text-transform: uppercase; border-radius: 2px; font-weight: 700; letter-spacing: 0.5px;
            background: var(--border); color: var(--dim);
        }
        .status-badge.secure { background: rgba(76, 175, 80, 0.2); color: var(--success); border: 1px solid var(--success); }
        .status-badge.error { background: rgba(244, 67, 54, 0.2); color: var(--error); border: 1px solid var(--error); }
        .status-badge.warn { background: rgba(255, 152, 0, 0.2); color: var(--warning); border: 1px solid var(--warning); }
        .status-badge.handshake { background: rgba(33, 150, 243, 0.2); color: #2196F3; border: 1px solid #2196F3; }

        /* MODAL */
        .modal-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.95); z-index: 2000;
            display: flex; align-items: center; justify-content: center;
            opacity: 0; pointer-events: none; transition: opacity 0.2s;
        }
        .modal-overlay.active { opacity: 1; pointer-events: all; }
        .modal { 
            background: var(--surface); border: 1px solid var(--accent); 
            padding: 30px; max-width: 450px; width: 95%; text-align: center;
            box-shadow: 0 0 30px rgba(0,0,0,0.8);
        }
        .file-list-preview {
            max-height: 150px; overflow-y: auto; text-align: left; background: var(--bg);
            border: 1px solid var(--border); padding: 10px; margin: 15px 0; font-size: 11px;
        }
        .file-entry { padding: 4px 0; border-bottom: 1px solid #222; display: flex; justify-content: space-between; }
        .file-entry:last-child { border-bottom: none; }

        /* TRANSFER UI */
        .transfer-item { 
            background: var(--bg); border: 1px solid var(--border); padding: 15px; margin-bottom: 10px;
            position: relative; overflow: hidden;
        }
        .progress-track { background: var(--border); height: 2px; width: 100%; margin: 12px 0; }
        .progress-fill { background: var(--accent); height: 100%; width: 0%; transition: width 0.2s linear; }
        .meta-row { display: flex; justify-content: space-between; font-size: 11px; color: var(--dim); margin-top: 5px; }

        /* QR & SCANNER */
        #qr-target { background: white; padding: 10px; display: inline-block; margin: 15px auto; border-radius: 4px; }
        #reader { width: 100%; border: 1px solid var(--border); border-radius: 4px; overflow: hidden; margin-bottom: 15px; }

        /* DRAG OVERLAY */
        #drag-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9); border: 2px dashed var(--accent);
            z-index: 1500; display: flex; align-items: center; justify-content: center;
            flex-direction: column; pointer-events: none; opacity: 0; transition: opacity 0.2s;
        }
        #drag-overlay.active { opacity: 1; pointer-events: all; }

        /* TOAST */
        .toast {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: var(--accent); color: var(--bg); padding: 12px 24px; 
            font-weight: 700; opacity: 0; transition: opacity 0.3s; z-index: 3000;
            pointer-events: none; border-radius: 2px; text-transform: uppercase; font-size: 11px;
        }
        .toast.show { opacity: 1; }

    </style>
</head>
<body>

    <!-- DRAG OVERLAY -->
    <div id="drag-overlay">
        <h1 style="border:none; font-size: 24px;">Drop Files to Send</h1>
    </div>

    <!-- MODAL: INCOMING BUNDLE -->
    <div id="modal-bundle" class="modal-overlay">
        <div class="modal">
            <h2>Incoming Bundle</h2>
            <p>Peer wants to send <span id="bundle-count" style="color:white; font-weight:bold">0</span> files:</p>
            
            <div id="bundle-preview" class="file-list-preview"></div>
            
            <p id="bundle-total-size" style="text-align: right; font-weight: bold; margin-bottom: 15px;">Total: 0 MB</p>
            
            <div class="flex-col">
                <button class="btn success" onclick="app.acceptBundle('zip')">Download as ZIP Archive</button>
                <button class="btn outline" onclick="app.acceptBundle('individual')">Download Individually</button>
                <button class="btn danger" onclick="app.rejectBundle()" style="margin-top:10px;">Reject All</button>
            </div>
        </div>
    </div>

    <div class="container">
        <!-- HEADER -->
        <header class="flex-row">
            <div class="flex-col" style="gap:2px;">
                <span style="font-weight:700; letter-spacing:1px; color:white;">GHOSTSHARE</span>
                <span style="font-size:10px; color:var(--dim);">SECURE P2P RUNTIME</span>
            </div>
            <div id="status-badge" class="status-badge">INIT</div>
        </header>

        <!-- VIEW: IDENTITY -->
        <div id="view-identity" class="card center fade-in">
            <h2>Session Identity</h2>
            <div id="my-id" style="font-size: 32px; font-weight: 700; letter-spacing: 4px; margin: 15px 0; color: var(--accent);">...</div>
            <p style="font-size: 11px;">Identity rotates on disconnect</p>
            
            <div id="qr-target" class="hidden"></div>
            
            <div class="flex-row" style="margin-top: 15px;">
                <button class="btn outline" onclick="app.copyId()">Copy ID</button>
                <button class="btn outline" onmousedown="app.startBroadcast()" onmouseup="app.stopBroadcast()" ontouchstart="app.startBroadcast()" ontouchend="app.stopBroadcast()">ðŸ”Š Hold to Air-Drop ID</button>
                <button class="btn outline" onclick="app.toggleQr()">Show QR</button>
            </div>
        </div>

        <!-- VIEW: CONNECT -->
        <div id="view-connect" class="card fade-in">
            <h2>Establish Tunnel</h2>
            
            <div id="reader-container" class="hidden">
                <div id="reader"></div>
                <button class="btn outline" onclick="app.stopScanner()" style="margin-bottom: 10px;">Cancel Camera</button>
            </div>

            <input type="text" id="peer-id-input" placeholder="ENTER PEER ID" maxlength="12" autocomplete="off">
            <div class="flex-row">
                <button class="btn" id="btn-connect" onclick="app.connect()">Connect</button>
                <button class="btn outline" id="btn-listen" onclick="app.toggleListen()">ðŸ‘‚ Listen</button>
                <button class="btn outline" onclick="app.startScanner()" style="width: auto;">ðŸ“·</button>
            </div>
        </div>

        <!-- VIEW: WORKSPACE (Hidden until secure) -->
        <div id="view-workspace" class="hidden flex-col" style="flex:1;">
            <div class="card flex-row" style="background: var(--bg); border: 1px dashed var(--dim); padding: 15px;">
                <div class="flex-col" style="gap:2px;">
                    <span style="color:var(--accent); font-weight:700;">SECURE CHANNEL VERIFIED</span>
                    <span style="font-size:10px; color:var(--success);">Mutual Auth â€¢ ECDH Key Exchange â€¢ HMAC Signed</span>
                </div>
                <button class="btn danger" style="width:auto; padding:8px 12px; font-size:10px;" onclick="app.disconnect()">End Session</button>
            </div>

            <div class="card center" style="border: 2px dashed var(--border); padding: 30px; cursor: pointer; transition: 0.2s;" 
                 onclick="document.getElementById('file-input').click()"
                 onmouseover="this.style.borderColor='var(--accent)'" 
                 onmouseout="this.style.borderColor='var(--border)'">
                <p><strong>CLICK TO UPLOAD</strong></p>
                <p style="font-size:11px;">or Drag & Drop Files</p>
                <input type="file" id="file-input" style="display: none" multiple onchange="app.handleFiles(this.files)">
            </div>

            <div id="transfer-list" class="flex-col scroll-y"></div>
        </div>
    </div>

    <!-- TOAST -->
    <div id="toast" class="toast">Alert</div>

<script>
/**
 * AUDIO MODEM IMPLEMENTATION (19kHz FSK)
 * Specs: 19000Hz (0) / 19500Hz (1)
 * Packet: [0xAA HEADER] + [DATA] + [CHECKSUM]
 */
class AudioModem {
    constructor() {
        this.ctx = null;
        this.FREQ_LOW = 19000;
        this.FREQ_HIGH = 19500;
        this.BIT_TIME = 0.048; // 48ms per bit (~21 baud) - optimized for robustness
        this.HEADER = 0xAA; // 10101010
        this.isBroadcasting = false;
        this.isListening = false;
        this.osc = null;
    }

    async initCtx() {
        if (!this.ctx) {
            this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (this.ctx.state === 'suspended') {
            await this.ctx.resume();
        }
        return this.ctx;
    }

    // --- TRANSMITTER ---
    async transmit(text) {
        if (this.isBroadcasting) return;
        this.isBroadcasting = true;
        const ctx = await this.initCtx();

        // 1. Convert Text to Bit Array (Header + Text + Checksum)
        const bytes = new TextEncoder().encode(text);
        let checksum = 0;
        bytes.forEach(b => checksum = (checksum + b) % 255);
        
        const packet = [this.HEADER, ...bytes, checksum];
        const bits = [];
        packet.forEach(byte => {
            for (let i = 7; i >= 0; i--) bits.push((byte >> i) & 1);
        });

        // 2. Setup Oscillator
        const osc = ctx.createOscillator();
        const gain = ctx.createGain();
        osc.connect(gain);
        gain.connect(ctx.destination);
        
        const now = ctx.currentTime;
        const fade = 0.005;

        // 3. Schedule Frequencies
        // Lead-in silence
        gain.gain.setValueAtTime(0, now);
        gain.gain.linearRampToValueAtTime(1, now + fade);

        bits.forEach((bit, i) => {
            const time = now + (i * this.BIT_TIME);
            osc.frequency.setValueAtTime(bit ? this.FREQ_HIGH : this.FREQ_LOW, time);
        });

        // 4. Cleanup
        const endTime = now + (bits.length * this.BIT_TIME);
        gain.gain.setValueAtTime(1, endTime - fade);
        gain.gain.linearRampToValueAtTime(0, endTime);
        
        osc.start(now);
        osc.stop(endTime);
        
        this.osc = osc;
        
        // Loop transmission if still holding button
        osc.onended = () => {
            this.isBroadcasting = false;
            if (this.shouldLoop) this.transmit(text);
        };
    }

    startLoop(text) {
        this.shouldLoop = true;
        this.transmit(text);
    }

    stopLoop() {
        this.shouldLoop = false;
        if(this.osc) {
            try { this.osc.stop(); } catch(e){}
            this.isBroadcasting = false;
        }
    }

    // --- RECEIVER ---
    async listen(onFound) {
        if (this.isListening) return;
        const ctx = await this.initCtx();

        // Mobile Constraint: No echo cancellation to preserve high freq
        const stream = await navigator.mediaDevices.getUserMedia({
            audio: { echoCancellation: false, noiseSuppression: false, autoGainControl: false }
        });

        const source = ctx.createMediaStreamSource(stream);
        const analyzer = ctx.createAnalyser();
        analyzer.fftSize = 2048; // Resolution ~23Hz per bin
        source.connect(analyzer);

        const buffer = new Float32Array(analyzer.frequencyBinCount);
        this.isListening = true;

        // Decoder State
        let bitBuffer = []; 
        let lastBit = -1;
        let sameBitCount = 0;
        const SAMPLES_PER_BIT = 3; // Approx frames per bit duration
        
        const process = () => {
            if (!this.isListening) {
                stream.getTracks().forEach(t => t.stop());
                return;
            }

            analyzer.getFloatFrequencyData(buffer);

            // Simple Energy Detection
            // 48000Hz / 2048 = 23.4Hz per bin
            // 19000 / 23.4 = ~811
            // 19500 / 23.4 = ~833
            const binLow = Math.floor(this.FREQ_LOW / (ctx.sampleRate / analyzer.fftSize));
            const binHigh = Math.floor(this.FREQ_HIGH / (ctx.sampleRate / analyzer.fftSize));
            
            const p0 = buffer[binLow];
            const p1 = buffer[binHigh];
            const threshold = -70; // dB

            let currentBit = -1;
            if (p0 > threshold && p0 > p1 + 5) currentBit = 0;
            else if (p1 > threshold && p1 > p0 + 5) currentBit = 1;

            // Voting / Debounce
            if (currentBit !== -1) {
                if (currentBit === lastBit) sameBitCount++;
                else { lastBit = currentBit; sameBitCount = 0; }
            }

            // Sample into bit stream if stable
            if (sameBitCount > SAMPLES_PER_BIT) {
                // Determine if we need to shift (simple edge detection logic simplified for stream)
                // For this lightweight version, we just push stable bits but limit rate
                // A robust PLL is too large, so we use a sliding window packet scanner
                bitBuffer.push(currentBit);
                sameBitCount = 0; // Reset to wait for next stable read
                
                // Keep buffer manageable size (Header + 12 chars + Sum = ~110 bits. Buffer 200)
                if (bitBuffer.length > 200) bitBuffer.shift();

                this.scanBuffer(bitBuffer, onFound);
            }

            requestAnimationFrame(process);
        };
        process();
    }

    scanBuffer(bits, callback) {
        // Look for Header (0xAA = 10101010)
        // We scan from the end backwards or reconstruct bytes
        // Simple approach: Convert last N bits to bytes and check structure
        
        if (bits.length < 100) return;

        // Try to frame from every possible start position in the buffer
        for (let i = 0; i < bits.length - 80; i++) {
            // Check Header
            let header = 0;
            for(let b=0; b<8; b++) header = (header << 1) | bits[i+b];
            
            if (header === this.HEADER) {
                // Header found, try decode next 13 bytes (12 ID + 1 Sum)
                const bytes = [];
                let ptr = i + 8;
                
                for (let c=0; c<13; c++) {
                    let val = 0;
                    for (let b=0; b<8; b++) {
                        if (ptr >= bits.length) return;
                        val = (val << 1) | bits[ptr++];
                    }
                    bytes.push(val);
                }

                // Verify Checksum
                const receivedSum = bytes.pop();
                const payload = bytes;
                let calcSum = 0;
                payload.forEach(b => calcSum = (calcSum + b) % 255);

                if (calcSum === receivedSum) {
                    const id = new TextDecoder().decode(new Uint8Array(payload));
                    // Basic sanity check for PeerID format
                    if (id.match(/^[A-Z0-9]{12}$/)) {
                        this.stopListen();
                        callback(id);
                        return;
                    }
                }
            }
        }
    }

    stopListen() {
        this.isListening = false;
    }
}

/**
 * GHOSTSHARE PRODUCTION RUNTIME v4.0
 * Features: Multi-file Bundles, ZIP Archiving, Serial Queueing, Audio Pairing
 */

// --- CONSTANTS ---
const CONFIG = {
    CHUNK_INITIAL: 16 * 1024,
    CHUNK_MAX: 256 * 1024,
    BUFFER_LIMIT: 8 * 1024 * 1024,
    ICE_SERVERS: [{ urls: 'stun:stun.l.google.com:19302' }],
    APP_URL: window.location.href.split('?')[0]
};

const STATES = {
    INIT: 'INIT',
    CONNECTING: 'CONNECTING',
    HANDSHAKING: 'HANDSHAKING',
    VERIFIED: 'VERIFIED',
    FAILED: 'FAILED'
};

// --- ZIP WRITER (VANILLA JS) ---
class ZipWriter {
    constructor() {
        this.files = [];
        this.crcTable = this.makeCrcTable();
    }

    makeCrcTable() {
        let c;
        const crcTable = [];
        for (let n = 0; n < 256; n++) {
            c = n;
            for (let k = 0; k < 8; k++) c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
            crcTable[n] = c;
        }
        return crcTable;
    }

    crc32(buf) {
        let crc = 0 ^ (-1);
        for (let i = 0; i < buf.length; i++) {
            crc = (crc >>> 8) ^ this.crcTable[(crc ^ buf[i]) & 0xFF];
        }
        return (crc ^ (-1)) >>> 0;
    }

    add(name, data) {
        this.files.push({ name, data });
    }

    generate() {
        const parts = [];
        let offset = 0;
        const centralDir = [];

        // Write Local File Headers & Data
        for (const file of this.files) {
            const nameBytes = new TextEncoder().encode(file.name);
            const data = new Uint8Array(file.data);
            const crc = this.crc32(data);
            const size = data.length;

            // Local Header
            const header = new Uint8Array(30 + nameBytes.length);
            const view = new DataView(header.buffer);

            view.setUint32(0, 0x04034b50, true); // Sig
            view.setUint16(4, 0x000A, true); // Version
            view.setUint16(6, 0x0000, true); // Flags
            view.setUint16(8, 0x0000, true); // Compression (Store)
            view.setUint32(14, crc, true);
            view.setUint32(18, size, true); // Compressed
            view.setUint32(22, size, true); // Uncompressed
            view.setUint16(26, nameBytes.length, true);
            view.setUint16(28, 0, true); // Extra len

            header.set(nameBytes, 30);
            
            parts.push(header);
            parts.push(data);

            // Record for Central Directory
            centralDir.push({ nameBytes, crc, size, offset });
            offset += header.length + size;
        }

        const dirStart = offset;

        // Write Central Directory
        for (const cd of centralDir) {
            const header = new Uint8Array(46 + cd.nameBytes.length);
            const view = new DataView(header.buffer);

            view.setUint32(0, 0x02014b50, true);
            view.setUint16(4, 0x000A, true);
            view.setUint16(6, 0x000A, true);
            view.setUint16(8, 0x0000, true);
            view.setUint16(10, 0x0000, true); // Compression
            view.setUint32(16, cd.crc, true);
            view.setUint32(20, cd.size, true);
            view.setUint32(24, cd.size, true);
            view.setUint16(28, cd.nameBytes.length, true);
            view.setUint32(42, cd.offset, true);

            header.set(cd.nameBytes, 46);
            parts.push(header);
            offset += header.length;
        }

        // End of Central Directory
        const eocd = new Uint8Array(22);
        const view = new DataView(eocd.buffer);
        view.setUint32(0, 0x06054b50, true);
        view.setUint16(8, this.files.length, true); // Disk records
        view.setUint16(10, this.files.length, true); // Total records
        view.setUint32(12, offset - dirStart, true); // Size of CD
        view.setUint32(16, dirStart, true); // Offset of CD

        parts.push(eocd);

        return new Blob(parts, { type: 'application/zip' });
    }
}

// --- CRYPTO UTILS ---
const Crypto = {
    async generateKeyPair() {
        return window.crypto.subtle.generateKey({ name: "ECDH", namedCurve: "P-256" }, true, ["deriveBits"]);
    },
    async exportKey(key) { return window.crypto.subtle.exportKey("jwk", key); },
    async importKey(jwk) { return window.crypto.subtle.importKey("jwk", jwk, { name: "ECDH", namedCurve: "P-256" }, true, []); },
    async deriveHMACKey(privateKey, publicKey) {
        const bits = await window.crypto.subtle.deriveBits({ name: "ECDH", public: publicKey }, privateKey, 256);
        return window.crypto.subtle.importKey("raw", bits, { name: "HMAC", hash: "SHA-256" }, false, ["sign", "verify"]);
    },
    async sign(key, data) { return window.crypto.subtle.sign("HMAC", key, data); },
    async verify(key, signature, data) { return window.crypto.subtle.verify("HMAC", key, signature, data); },
    randomNonce() { return window.crypto.getRandomValues(new Uint8Array(32)); }
};

// --- APP LOGIC ---
class GhostShare {
    constructor() {
        this.state = STATES.INIT;
        this.peer = null;
        this.conn = null;
        this.myId = null;
        
        // Modules
        this.audio = new AudioModem();

        // Security Context
        this.keyPair = null;
        this.hmacKey = null; 
        this.myNonce = null;

        // Transfers
        this.transfers = {}; 
        this.uploadQueue = []; // Array of file objects to send serially
        this.isUploading = false;

        // Bundle State
        this.pendingBundle = null; // Incoming offer
        this.activeBundle = null; // Currently receiving bundle { id, mode, files: [], completed: [] }

        // UI Refs
        this.dom = {
            status: document.getElementById('status-badge'),
            myId: document.getElementById('my-id'),
            peerInput: document.getElementById('peer-id-input'),
            viewIdentity: document.getElementById('view-identity'),
            viewConnect: document.getElementById('view-connect'),
            viewWorkspace: document.getElementById('view-workspace'),
            transferList: document.getElementById('transfer-list'),
            modalBundle: document.getElementById('modal-bundle'),
            bundlePreview: document.getElementById('bundle-preview'),
            toast: document.getElementById('toast'),
            btnConnect: document.getElementById('btn-connect'),
            btnListen: document.getElementById('btn-listen')
        };

        this.init();
        this.setupDragDrop();
    }

    // --- AUDIO PAIRING ---
    startBroadcast() {
        if(!this.myId) return;
        this.audio.startLoop(this.myId);
        this.toast("Broadcasting ID via Audio...");
    }

    stopBroadcast() {
        this.audio.stopLoop();
    }

    toggleListen() {
        if (this.audio.isListening) {
            this.audio.stopListen();
            this.dom.btnListen.innerText = "ðŸ‘‚ Listen";
            this.dom.btnListen.classList.remove('listening');
        } else {
            this.dom.btnListen.innerText = "Scanning...";
            this.dom.btnListen.classList.add('listening');
            this.audio.listen((id) => {
                this.dom.peerInput.value = id;
                this.toggleListen(); // Stop listening
                this.toast("Peer Found via Audio!");
                
                // Optional: Auto Connect if desired
                // this.connect();
            }).catch(e => {
                this.toast("Mic Error: " + e.message);
                this.toggleListen();
            });
        }
    }

    // --- INITIALIZATION ---
    async init() {
        const array = new Uint8Array(4);
        window.crypto.getRandomValues(array);
        this.myId = Array.from(array, byte => byte.toString(16).padStart(2, '0')).join('').toUpperCase();
        
        this.dom.myId.innerText = this.myId;
        this.generateQr();
        this.checkDeepLink();

        this.peer = new Peer(this.myId, { debug: 1, config: { iceServers: CONFIG.ICE_SERVERS } });

        this.peer.on('open', () => this.updateState(STATES.INIT));
        this.peer.on('connection', (conn) => this.handleIncomingConnection(conn));
        this.peer.on('error', (err) => {
            console.error(err);
            this.toast(`Net Error: ${err.type}`);
            if(err.type === 'peer-unavailable') this.resetUI();
        });
    }

    // --- CONNECTION & SECURITY ---
    connect() {
        const input = this.dom.peerInput.value.trim().toUpperCase();
        const id = this.extractId(input);
        if(!id || id === this.myId) return this.toast("Invalid Peer ID");
        this.updateState(STATES.CONNECTING);
        const conn = this.peer.connect(id, { reliable: true });
        this.setupConnection(conn);
    }

    handleIncomingConnection(conn) {
        if (this.state === STATES.VERIFIED) { conn.close(); return; }
        this.updateState(STATES.CONNECTING);
        this.setupConnection(conn);
    }

    setupConnection(conn) {
        this.conn = conn;
        conn.on('open', async () => {
            this.updateState(STATES.HANDSHAKING);
            this.keyPair = await Crypto.generateKeyPair();
            const exported = await Crypto.exportKey(this.keyPair.publicKey);
            conn.send({ type: 'HS_KEY', key: exported });
        });
        conn.on('data', (data) => this.handleData(data));
        conn.on('close', () => this.disconnect());
        conn.on('error', () => this.disconnect());
    }

    async handleData(msg) {
        try {
            switch(msg.type) {
                // HANDSHAKE
                case 'HS_KEY':
                    if (this.state !== STATES.HANDSHAKING) return;
                    const remoteKey = await Crypto.importKey(msg.key);
                    this.hmacKey = await Crypto.deriveHMACKey(this.keyPair.privateKey, remoteKey);
                    this.myNonce = Crypto.randomNonce();
                    this.conn.send({ type: 'HS_CHALLENGE', nonce: Array.from(this.myNonce) });
                    break;
                case 'HS_CHALLENGE':
                    if (this.state !== STATES.HANDSHAKING || !this.hmacKey) return;
                    const sig = await Crypto.sign(this.hmacKey, new Uint8Array(msg.nonce));
                    this.conn.send({ type: 'HS_PROOF', sig: Array.from(new Uint8Array(sig)) });
                    break;
                case 'HS_PROOF':
                    if (this.state !== STATES.HANDSHAKING || !this.hmacKey || !this.myNonce) return;
                    const valid = await Crypto.verify(this.hmacKey, new Uint8Array(msg.sig), this.myNonce);
                    if (valid) {
                        this.updateState(STATES.VERIFIED);
                        this.toast("Secure Connection Verified");
                    } else {
                        this.disconnect();
                    }
                    break;

                // DATA PLANE
                case 'BUNDLE_OFFER':
                    if (this.state !== STATES.VERIFIED) return;
                    this.handleBundleOffer(msg);
                    break;
                case 'BUNDLE_ACCEPT':
                    if (this.state !== STATES.VERIFIED) return;
                    this.processUploadQueue(); // Start sending
                    break;
                case 'BUNDLE_REJECT':
                    this.toast("Bundle Rejected");
                    this.uploadQueue = [];
                    break;
                case 'META':
                    if (this.state !== STATES.VERIFIED) return;
                    this.initDownload(msg);
                    break;
                case 'CHUNK':
                    if (this.state !== STATES.VERIFIED) return;
                    this.handleChunk(msg);
                    break;
                case 'ACK_FIN':
                    if (this.state !== STATES.VERIFIED) return;
                    this.finalizeTransfer(msg.id, true);
                    break;
            }
        } catch (e) {
            console.error("Protocol Error", e);
            this.disconnect();
        }
    }

    // --- BUNDLE LOGIC (RECEIVER) ---
    handleBundleOffer(msg) {
        this.pendingBundle = msg;
        
        // Populate UI
        document.getElementById('bundle-count').innerText = msg.files.length;
        const totalSize = msg.files.reduce((acc, f) => acc + f.size, 0);
        document.getElementById('bundle-total-size').innerText = `Total: ${this.formatBytes(totalSize)}`;
        
        const preview = this.dom.bundlePreview;
        preview.innerHTML = '';
        msg.files.forEach(f => {
            const div = document.createElement('div');
            div.className = 'file-entry';
            div.innerHTML = `<span>${f.name}</span><span>${this.formatBytes(f.size)}</span>`;
            preview.appendChild(div);
        });

        this.dom.modalBundle.classList.add('active');
    }

    acceptBundle(mode) {
        this.dom.modalBundle.classList.remove('active');
        const offer = this.pendingBundle;
        
        this.activeBundle = {
            id: offer.id,
            mode: mode, // 'zip' or 'individual'
            totalFiles: offer.files.length,
            completedFiles: [],
            zipParts: [] // To store file data for zip
        };

        this.conn.send({ type: 'BUNDLE_ACCEPT', bundleId: offer.id });
    }

    rejectBundle() {
        this.dom.modalBundle.classList.remove('active');
        this.conn.send({ type: 'BUNDLE_REJECT', bundleId: this.pendingBundle.id });
        this.pendingBundle = null;
    }

    // --- TRANSFER LOGIC ---

    // SENDER SIDE
    handleFiles(files) {
        if (this.state !== STATES.VERIFIED) return this.toast("Not Connected");
        
        const fileList = Array.from(files);
        if (fileList.length === 0) return;

        // Create Bundle Offer
        const bundleId = Date.now().toString(36);
        const metaList = fileList.map(f => ({
            name: f.name,
            size: f.size,
            mime: f.type,
            id: bundleId + '_' + Math.random().toString(36).substr(2, 5)
        }));

        this.uploadQueue = fileList.map((f, i) => ({
            file: f,
            meta: metaList[i]
        }));

        this.conn.send({ type: 'BUNDLE_OFFER', id: bundleId, files: metaList });
        this.toast("Offer Sent...");
    }

    processUploadQueue() {
        if (this.uploadQueue.length === 0) {
            this.toast("Bundle Completed");
            return;
        }

        const item = this.uploadQueue.shift(); // Get next file
        this.startUpload(item);
    }

    startUpload(item) {
        const id = item.meta.id;
        const file = item.file;

        this.transfers[id] = {
            role: 'sender',
            file: file,
            size: file.size,
            name: file.name,
            sent: 0,
            status: 'TRANSFERRING',
            startTime: Date.now(),
            lastTime: Date.now(),
            chunkSize: CONFIG.CHUNK_INITIAL
        };

        this.createTransferUI(id, file.name, file.size, 'upload');

        // Send META for this specific file
        this.conn.send({ type: 'META', ...item.meta });

        // Start Chunking
        const reader = new FileReader();
        let offset = 0;
        const t = this.transfers[id];

        const pump = () => {
            if (t.status !== 'TRANSFERRING' || !this.conn.open) return;

            if (this.conn.dataChannel.bufferedAmount > CONFIG.BUFFER_LIMIT) {
                setTimeout(pump, 50);
                return;
            }

            // Adaptive Chunk Size
            const buffered = this.conn.dataChannel.bufferedAmount;
            if (buffered < CONFIG.CHUNK_INITIAL) t.chunkSize = Math.min(t.chunkSize * 2, CONFIG.CHUNK_MAX);
            else t.chunkSize = Math.max(t.chunkSize / 2, CONFIG.CHUNK_INITIAL);

            const slice = file.slice(offset, offset + t.chunkSize);
            reader.readAsArrayBuffer(slice);
        };

        reader.onload = (e) => {
            const data = e.target.result;
            this.conn.send({ type: 'CHUNK', id: id, data: data });
            offset += data.byteLength;
            t.sent = offset;
            this.updateMetrics(id);

            if (offset < t.size) {
                pump();
            } else {
                t.status = 'AWAITING_FIN';
            }
        };

        pump();
    }

    // RECEIVER SIDE
    initDownload(msg) {
        this.transfers[msg.id] = {
            role: 'receiver',
            size: msg.size,
            name: msg.name,
            mime: msg.mime,
            received: 0,
            status: 'TRANSFERRING',
            chunks: [],
            startTime: Date.now(),
            lastTime: Date.now()
        };
        this.createTransferUI(msg.id, msg.name, msg.size, 'download');
    }

    handleChunk(msg) {
        const t = this.transfers[msg.id];
        if (!t) return;

        const data = new Uint8Array(msg.data);
        t.chunks.push(data);
        t.received += data.byteLength;
        this.updateMetrics(msg.id);

        if (t.received >= t.size) {
            this.finishReceive(msg.id);
        }
    }

    finishReceive(id) {
        const t = this.transfers[id];
        t.status = 'COMPLETED';
        this.updateTransferUI(id);
        
        // Construct Blob
        const blob = new Blob(t.chunks, { type: t.mime });

        // Bundle Handling
        if (this.activeBundle) {
            if (this.activeBundle.mode === 'zip') {
                this.activeBundle.completedFiles.push({
                    name: t.name,
                    data: blob 
                });
            } else {
                // Individual Mode: Download immediately
                this.downloadBlob(blob, t.name);
            }

            // Check if bundle complete
            // (Wait for zip finalization if zip mode, else just count)
        } else {
            // Single file (legacy fallback)
            this.downloadBlob(blob, t.name);
        }

        // ACK and Cleanup
        this.conn.send({ type: 'ACK_FIN', id: id });
        t.chunks = null; // GC
        
        // Logic for ZIP finalization
        if (this.activeBundle && this.activeBundle.mode === 'zip') {
             if (this.activeBundle.completedFiles.length === this.activeBundle.totalFiles) {
                 this.finalizeZipBundle();
             }
        }
    }

    async finalizeZipBundle() {
        this.toast("Creating ZIP Archive...");
        const zip = new ZipWriter();
        
        for (const f of this.activeBundle.completedFiles) {
            const buf = await f.data.arrayBuffer();
            zip.add(f.name, buf);
        }

        const zipBlob = zip.generate();
        this.downloadBlob(zipBlob, `bundle_${Date.now()}.zip`);
        this.activeBundle = null;
        this.toast("Bundle Downloaded");
    }

    finalizeTransfer(id) {
        // Sender Side: When ACK received, process next
        const t = this.transfers[id];
        if (t && t.role === 'sender') {
            t.status = 'COMPLETED';
            this.updateTransferUI(id);
            this.processUploadQueue(); // Trigger next file
        }
    }

    downloadBlob(blob, filename) {
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        setTimeout(() => URL.revokeObjectURL(url), 60000);
    }

    // --- UI HELPERS ---
    createTransferUI(id, name, size, type) {
        const div = document.createElement('div');
        div.className = 'transfer-item fade-in';
        div.id = `ui-${id}`;
        div.innerHTML = `
            <div class="flex-row">
                <span style="font-weight:700; color: ${type === 'upload' ? '#ff9800' : '#4caf50'}">
                    ${type === 'upload' ? 'SENDING' : 'RECEIVING'}
                </span>
                <span style="font-size:11px;">${name}</span>
            </div>
            <div class="progress-track">
                <div class="progress-fill" id="bar-${id}"></div>
            </div>
            <div class="meta-row">
                <span id="prog-${id}">0%</span>
                <span id="speed-${id}">-- MB/s</span>
            </div>
        `;
        this.dom.transferList.prepend(div);
    }

    updateMetrics(id) {
        const t = this.transfers[id];
        if(!t) return;
        
        const now = Date.now();
        const processed = t.role === 'sender' ? t.sent : t.received;
        const pct = Math.min(100, (processed / t.size) * 100).toFixed(1);
        
        const bar = document.getElementById(`bar-${id}`);
        if(bar) bar.style.width = `${pct}%`;
        const prog = document.getElementById(`prog-${id}`);
        if(prog) prog.innerText = `${pct}%`;

        if (now - t.lastTime > 500) {
            const bytesSince = processed - (t.lastBytes || 0);
            const timeDiff = (now - t.lastTime) / 1000;
            const speed = bytesSince / timeDiff;
            const spdEl = document.getElementById(`speed-${id}`);
            if(spdEl) spdEl.innerText = `${this.formatBytes(speed)}/s`;
            t.lastTime = now;
            t.lastBytes = processed;
        }
    }

    updateTransferUI(id) {
        const t = this.transfers[id];
        if (!t) return;
        if (t.status === 'COMPLETED') {
            document.getElementById(`bar-${id}`).style.background = 'var(--success)';
        }
    }

    updateState(newState) {
        this.state = newState;
        if (newState === STATES.VERIFIED) {
            this.dom.viewIdentity.classList.add('hidden');
            this.dom.viewConnect.classList.add('hidden');
            this.dom.viewWorkspace.classList.remove('hidden');
            this.dom.status.className = 'status-badge secure';
            this.dom.status.innerText = 'SECURE';
        } else if (newState === STATES.HANDSHAKING) {
            this.dom.status.className = 'status-badge handshake';
            this.dom.status.innerText = 'VERIFYING...';
        } else if (newState === STATES.INIT) {
            this.resetUI();
        } else {
            this.dom.status.className = 'status-badge warn';
            this.dom.status.innerText = newState;
        }
    }

    disconnect() {
        if (this.conn) this.conn.close();
        if (this.peer) this.peer.destroy();
        this.updateState(STATES.INIT);
        this.init(); 
    }

    resetUI() {
        this.dom.viewIdentity.classList.remove('hidden');
        this.dom.viewConnect.classList.remove('hidden');
        this.dom.viewWorkspace.classList.add('hidden');
        this.dom.transferList.innerHTML = '';
        this.dom.peerInput.value = '';
        this.dom.btnConnect.innerText = 'Connect';
        
        this.dom.btnListen.innerText = "ðŸ‘‚ Listen";
        this.dom.btnListen.classList.remove('listening');
        if(this.audio) this.audio.stopListen();

        this.dom.status.className = 'status-badge';
        this.dom.status.innerText = 'INIT';
        this.uploadQueue = [];
        this.activeBundle = null;
    }

    // --- UTILS ---
    extractId(input) { try { return new URL(input).searchParams.get('peer'); } catch(e) { return input; } }
    checkDeepLink() {
        const peer = new URLSearchParams(window.location.search).get('peer');
        if (peer) { this.dom.peerInput.value = peer; this.toast("Link Detected"); window.history.replaceState({}, document.title, window.location.pathname); }
    }
    generateQr() {
        const target = document.getElementById('qr-target'); target.innerHTML = '';
        new QRCode(target, { text: `${CONFIG.APP_URL}?peer=${this.myId}`, width: 150, height: 150, colorDark : "#000000", colorLight : "#ffffff", correctLevel : QRCode.CorrectLevel.L });
    }
    toggleQr() { document.getElementById('qr-target').classList.toggle('hidden'); }
    copyId() { navigator.clipboard.writeText(this.myId); this.toast("ID Copied"); }
    toast(msg) { this.dom.toast.innerText = msg; this.dom.toast.classList.add('show'); setTimeout(()=>this.dom.toast.classList.remove('show'), 3000); }
    formatBytes(bytes) {
        if (bytes === 0) return '0 B';
        const sizes = ['B', 'KB', 'MB', 'GB'];
        const i = Math.floor(Math.log(bytes) / Math.log(1024));
        return parseFloat((bytes / Math.pow(1024, i)).toFixed(2)) + ' ' + sizes[i];
    }
    startScanner() {
        document.getElementById('reader-container').classList.remove('hidden');
        this.scanner = new Html5Qrcode("reader");
        this.scanner.start({ facingMode: "environment" }, { fps: 10, qrbox: 250 }, (decoded) => {
            const id = this.extractId(decoded);
            if(id) { this.dom.peerInput.value = id; this.stopScanner(); this.connect(); }
        });
    }
    stopScanner() { if(this.scanner) this.scanner.stop().then(() => { document.getElementById('reader-container').classList.add('hidden'); }); }
    
    setupDragDrop() {
        const overlay = document.getElementById('drag-overlay');
        window.addEventListener('dragover', e => { e.preventDefault(); if(this.state===STATES.VERIFIED) overlay.classList.add('active'); });
        overlay.addEventListener('dragleave', e => { e.preventDefault(); overlay.classList.remove('active'); });
        overlay.addEventListener('drop', e => {
            e.preventDefault(); overlay.classList.remove('active');
            if(this.state===STATES.VERIFIED && e.dataTransfer.files.length) this.handleFiles(e.dataTransfer.files);
        });
    }
}

window.app = new GhostShare();
window.onbeforeunload = () => window.app.state === STATES.VERIFIED ? "Active Session" : undefined;
</script>
</body>
</html>
