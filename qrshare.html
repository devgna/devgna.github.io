<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>OPTILINK v1.3 | Robust Optical Transfer</title>
    
    <!-- Dependencies -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
    
    <!-- Icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

    <style>
        body { font-family: 'Inter', sans-serif; background-color: #0f172a; color: #e2e8f0; }
        .scan-line {
            position: absolute;
            width: 100%;
            height: 2px;
            background: #22c55e;
            animation: scan 2s linear infinite;
            box-shadow: 0 0 4px #22c55e;
        }
        @keyframes scan { 0% { top: 0; } 100% { top: 100%; } }
        canvas { border-radius: 0.5rem; }
        .hidden { display: none !important; }
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: #1e293b; }
        ::-webkit-scrollbar-thumb { background: #475569; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #64748b; }
    </style>
</head>
<body class="h-screen flex flex-col overflow-hidden">

    <!-- Header -->
    <header class="bg-slate-900 border-b border-slate-800 p-4 flex justify-between items-center shadow-lg z-10">
        <div class="flex items-center gap-3">
            <i class="fa-solid fa-qrcode text-emerald-500 text-2xl"></i>
            <h1 class="font-bold text-xl tracking-tight">OPTILINK <span class="text-xs font-mono text-slate-400 bg-slate-800 px-1 rounded">v1.3 STABLE</span></h1>
        </div>
        <div id="connection-status" class="flex items-center gap-2 text-sm text-amber-500 font-mono">
            <span class="relative flex h-3 w-3">
              <span class="animate-ping absolute inline-flex h-full w-full rounded-full bg-amber-400 opacity-75"></span>
              <span class="relative inline-flex rounded-full h-3 w-3 bg-amber-500"></span>
            </span>
            <span>Initializing P2P...</span>
        </div>
    </header>

    <!-- Main Content -->
    <main class="flex-1 flex flex-col md:flex-row overflow-hidden relative">
        
        <!-- Mode Selection Overlay -->
        <div id="mode-select" class="absolute inset-0 z-50 bg-slate-900/95 flex flex-col items-center justify-center gap-8 backdrop-blur-sm">
            <h2 class="text-3xl font-bold text-white mb-4">Select Role</h2>
            <div class="flex gap-8">
                <button onclick="app.setRole('sender')" class="group flex flex-col items-center gap-4 p-8 bg-slate-800 rounded-xl hover:bg-emerald-600 transition-all border border-slate-700 hover:border-emerald-500 hover:scale-105 shadow-xl w-64">
                    <i class="fa-solid fa-upload text-5xl text-emerald-400 group-hover:text-white"></i>
                    <div class="text-center">
                        <span class="block text-xl font-bold text-white">Sender</span>
                        <span class="text-sm text-slate-400 group-hover:text-emerald-100">Upload & Generate QR</span>
                    </div>
                </button>
                <button onclick="app.setRole('receiver')" class="group flex flex-col items-center gap-4 p-8 bg-slate-800 rounded-xl hover:bg-blue-600 transition-all border border-slate-700 hover:border-blue-500 hover:scale-105 shadow-xl w-64">
                    <i class="fa-solid fa-camera text-5xl text-blue-400 group-hover:text-white"></i>
                    <div class="text-center">
                        <span class="block text-xl font-bold text-white">Receiver</span>
                        <span class="text-sm text-slate-400 group-hover:text-blue-100">Scan & Download</span>
                    </div>
                </button>
            </div>
            <div class="mt-8 text-slate-500 text-sm max-w-md text-center">
                <p>Ensure both devices are on the same network if P2P fails, or simply ensure the camera can see the screen clearly.</p>
            </div>
        </div>

        <!-- SENDER VIEW -->
        <div id="sender-view" class="hidden flex-1 flex flex-col h-full bg-slate-900 p-6 items-center">
            
            <!-- File Input Area -->
            <div id="upload-area" class="w-full max-w-2xl mb-6 p-8 border-2 border-dashed border-slate-600 rounded-xl bg-slate-800/50 text-center hover:border-emerald-500 hover:bg-slate-800 transition-colors cursor-pointer" onclick="document.getElementById('file-input').click()">
                <input type="file" id="file-input" class="hidden" onchange="sender.handleFile(this.files[0])">
                <i class="fa-solid fa-cloud-arrow-up text-4xl text-slate-400 mb-3"></i>
                <p class="text-lg font-medium text-slate-300">Click to select file</p>
                <p class="text-sm text-slate-500">Max recommended: 10MB</p>
            </div>

            <!-- Transfer UI -->
            <div id="sender-ui" class="hidden w-full max-w-4xl flex flex-col items-center h-full">
                
                <div class="w-full flex justify-between items-end mb-4">
                    <div>
                        <h2 id="sender-filename" class="text-lg font-bold text-white truncate max-w-md">filename.ext</h2>
                        <div class="text-xs text-slate-400 font-mono">
                            <span id="sender-filesize">0 KB</span> • 
                            SEQ: <span id="sender-seq" class="text-emerald-400">0</span> • 
                            WND: <span id="sender-window" class="text-blue-400">0</span>
                        </div>
                    </div>
                    <div class="flex gap-2">
                         <button onclick="sender.togglePause()" id="sender-pause-btn" class="px-4 py-2 bg-amber-600 hover:bg-amber-500 rounded text-white text-sm font-bold shadow transition-colors">
                            <i class="fa-solid fa-pause"></i> PAUSE
                        </button>
                        <button onclick="location.reload()" class="px-4 py-2 bg-slate-700 hover:bg-slate-600 rounded text-white text-sm font-bold shadow transition-colors">
                            CANCEL
                        </button>
                    </div>
                </div>

                <!-- QR Container -->
                <div class="relative bg-white p-4 rounded-xl shadow-2xl flex-shrink-0 mb-4">
                    <div id="qrcode" class="w-[300px] h-[300px] md:w-[400px] md:h-[400px]"></div>
                    <div id="sender-complete-overlay" class="hidden absolute inset-0 bg-emerald-500/90 rounded-xl flex flex-col items-center justify-center text-white backdrop-blur-sm">
                        <i class="fa-solid fa-check-circle text-6xl mb-2"></i>
                        <span class="text-2xl font-bold">SENT</span>
                    </div>
                </div>

                <!-- Stats/Logs -->
                <div class="w-full bg-slate-800 rounded-lg p-4 flex-1 overflow-hidden flex flex-col border border-slate-700">
                    <div class="flex justify-between text-xs font-bold text-slate-400 mb-2 uppercase tracking-wider">
                        <span>Transfer Log</span>
                        <span id="sender-progress">0%</span>
                    </div>
                    <div class="w-full bg-slate-700 h-2 rounded-full mb-3 overflow-hidden">
                        <div id="sender-progress-bar" class="h-full bg-emerald-500 w-0 transition-all duration-300"></div>
                    </div>
                    <div id="sender-log" class="font-mono text-xs text-slate-300 overflow-y-auto flex-1 space-y-1 p-2 bg-slate-900/50 rounded border border-slate-700/50">
                        <div class="text-emerald-500">System initialized. Waiting for file...</div>
                    </div>
                </div>
            </div>
        </div>

        <!-- RECEIVER VIEW -->
        <div id="receiver-view" class="hidden flex-1 flex flex-col h-full bg-black relative">
            
            <!-- Camera Overlay UI -->
            <div class="absolute top-4 left-4 right-4 z-20 flex justify-between items-start pointer-events-none">
                <div class="bg-slate-900/80 backdrop-blur text-white px-3 py-2 rounded-lg border border-slate-700 pointer-events-auto">
                    <h2 class="text-xs font-bold text-slate-400 uppercase">Receiving</h2>
                    <div id="rx-filename" class="font-bold truncate max-w-[150px]">Waiting...</div>
                </div>
                <div class="bg-slate-900/80 backdrop-blur text-white px-3 py-2 rounded-lg border border-slate-700 pointer-events-auto flex flex-col items-end">
                    <div class="text-xs font-bold text-slate-400 uppercase">Throughput</div>
                    <div class="font-mono text-emerald-400 font-bold"><span id="rx-fps">0</span> FPS</div>
                    <div class="font-mono text-xs text-slate-400"><span id="rx-bps">0</span> KB/s</div>
                </div>
            </div>

            <!-- Main Canvas -->
            <div class="relative w-full h-full flex items-center justify-center bg-black overflow-hidden">
                <video id="video" playsinline class="hidden"></video>
                <canvas id="canvas" class="w-full h-full object-contain"></canvas>
                
                <!-- Scanning Guide -->
                <div id="scan-guide" class="absolute w-64 h-64 border-2 border-emerald-500/50 rounded-lg box-border shadow-[0_0_100px_rgba(16,185,129,0.2)]">
                    <div class="scan-line"></div>
                    <div class="absolute -top-6 w-full text-center text-emerald-400 text-xs font-bold uppercase tracking-widest bg-black/50 py-1 rounded">Align QR Code</div>
                </div>
            </div>

            <!-- Bottom Controls -->
            <div class="absolute bottom-0 w-full bg-slate-900/90 backdrop-blur border-t border-slate-800 p-4 z-20 pb-8 md:pb-4">
                <div class="flex items-center gap-4 mb-3">
                    <div class="flex-1">
                        <div class="flex justify-between text-xs text-slate-300 mb-1">
                            <span id="rx-progress-text">0 / 0 chunks</span>
                            <span id="rx-percent">0%</span>
                        </div>
                        <div class="w-full bg-slate-700 h-3 rounded-full overflow-hidden">
                            <div id="rx-progress-bar" class="h-full bg-emerald-500 w-0 transition-all duration-200"></div>
                        </div>
                    </div>
                    <button onclick="receiver.reset()" class="bg-slate-700 hover:bg-slate-600 text-white p-2 rounded-lg transition-colors">
                        <i class="fa-solid fa-rotate-right"></i>
                    </button>
                </div>
                
                <div id="rx-complete-msg" class="hidden bg-emerald-600 text-white p-3 rounded-lg text-center font-bold shadow-lg animate-bounce cursor-pointer hover:bg-emerald-500 transition-colors" onclick="receiver.downloadFile()">
                    <i class="fa-solid fa-download mr-2"></i> TRANSFER COMPLETE - CLICK TO DOWNLOAD
                </div>
                
                <div class="flex gap-2 mt-2 overflow-x-auto">
                    <select id="camera-select" class="bg-slate-800 text-white text-xs p-2 rounded border border-slate-700 outline-none focus:border-emerald-500">
                        <option value="environment">Rear Camera (Default)</option>
                        <option value="user">Front Camera</option>
                    </select>
                </div>
            </div>
        </div>
    </main>

    <!-- App Logic -->
    <script>
        // --- CONFIGURATION ---
        const PROTOCOL_VER = 1;
        const CHUNK_SIZE = 700; // Safe payload size for QR version 10-20
        const QR_ERROR_LEVEL = QRCode.CorrectLevel.L; // Lower error correction = more data
        const SCAN_FPS_LIMIT = 15; // Limit decode attempts per second
        const WINDOW_MAX_SIZE = 30;
        
        // --- UTILS ---
        const sleep = ms => new Promise(r => setTimeout(r, ms));
        const log = (msg, type='info') => {
            console.log(`[${type.toUpperCase()}] ${msg}`);
            // Also append to sender log if visible
            const logEl = document.getElementById('sender-log');
            if(logEl) {
                const div = document.createElement('div');
                div.className = type === 'error' ? 'text-red-400' : (type === 'success' ? 'text-emerald-400' : 'text-slate-300');
                div.innerText = `> ${msg}`;
                logEl.appendChild(div);
                logEl.scrollTop = logEl.scrollHeight;
            }
        };

        // --- GLOBAL STATE ---
        const app = {
            role: null,
            peer: null,
            conn: null,
            peerId: null,
            setRole: (r) => {
                app.role = r;
                document.getElementById('mode-select').classList.add('hidden');
                document.getElementById('connection-status').innerHTML = 
                    `<span class="text-emerald-400 font-bold">ID: ${app.peerId ? app.peerId.substring(0,4) : '...'}</span>`;
                
                if (r === 'sender') {
                    document.getElementById('sender-view').classList.remove('hidden');
                    sender.init();
                } else {
                    document.getElementById('receiver-view').classList.remove('hidden');
                    receiver.init();
                }
            },
            initP2P: () => {
                app.peer = new Peer(null, { debug: 1 });
                
                app.peer.on('open', (id) => {
                    app.peerId = id;
                    document.getElementById('connection-status').innerHTML = 
                        `<span class="text-emerald-400 font-bold"><i class="fa-solid fa-wifi mr-1"></i> READY (${id.substring(0,4)})</span>`;
                });

                app.peer.on('connection', (conn) => {
                    app.conn = conn;
                    app.setupConnHandlers();
                    // Auto-switch to receiver if connected to
                    if (!app.role) app.setRole('receiver');
                });

                app.peer.on('error', (err) => {
                    document.getElementById('connection-status').innerHTML = 
                        `<span class="text-red-500 font-bold">P2P Error</span>`;
                    console.error(err);
                });
            },
            connectToPeer: (remoteId) => {
                if (!app.peer) return;
                const conn = app.peer.connect(remoteId);
                app.conn = conn;
                app.setupConnHandlers();
            },
            setupConnHandlers: () => {
                app.conn.on('open', () => {
                    document.getElementById('connection-status').innerHTML = 
                        `<span class="text-blue-400 font-bold"><i class="fa-solid fa-link mr-1"></i> LINKED</span>`;
                    log("Control plane established via WebRTC", "success");
                });
                app.conn.on('data', (data) => {
                    if (app.role === 'sender') sender.handleControlMsg(data);
                });
                app.conn.on('close', () => {
                    log("Control plane disconnected", "error");
                });
            },
            sendControl: (msg) => {
                if (app.conn && app.conn.open) {
                    app.conn.send(msg);
                }
            }
        };

        // --- SENDER LOGIC ---
        const sender = {
            file: null,
            chunks: [],
            totalChunks: 0,
            acked: new Set(),
            nacked: new Set(),
            windowBase: 0,
            windowSize: 10, // Start conservative
            isPaused: false,
            isComplete: false,
            qrEl: null,
            qrObj: null,
            loopId: null,
            lastRenderTime: 0,
            
            // State: 'IDLE', 'TRANSFER', 'DRAINING', 'COMPLETE'
            state: 'IDLE',

            init: () => {
                sender.qrEl = document.getElementById('qrcode');
            },

            handleFile: async (file) => {
                if (!file) return;
                sender.file = file;
                document.getElementById('upload-area').classList.add('hidden');
                document.getElementById('sender-ui').classList.remove('hidden');
                
                document.getElementById('sender-filename').innerText = file.name;
                document.getElementById('sender-filesize').innerText = (file.size / 1024).toFixed(1) + ' KB';

                log(`Processing ${file.name}...`);
                
                // Chunking
                const buffer = await file.arrayBuffer();
                const bytes = new Uint8Array(buffer);
                sender.chunks = [];
                
                for (let i = 0; i < bytes.length; i += CHUNK_SIZE) {
                    const chunkBytes = bytes.slice(i, i + CHUNK_SIZE);
                    // Convert chunk to Base64 manually to ensure safety
                    let binary = '';
                    const len = chunkBytes.byteLength;
                    for (let j = 0; j < len; j++) {
                        binary += String.fromCharCode(chunkBytes[j]);
                    }
                    sender.chunks.push(window.btoa(binary));
                }
                
                sender.totalChunks = sender.chunks.length;
                log(`File split into ${sender.totalChunks} chunks.`);
                
                // Start Transfer
                sender.startTransfer();
            },

            startTransfer: () => {
                sender.state = 'TRANSFER';
                sender.acked.clear();
                sender.nacked.clear();
                sender.windowBase = 0;
                sender.isPaused = false;
                sender.isComplete = false;
                sender.loop();
            },

            togglePause: () => {
                sender.isPaused = !sender.isPaused;
                const btn = document.getElementById('sender-pause-btn');
                btn.innerHTML = sender.isPaused ? '<i class="fa-solid fa-play"></i> RESUME' : '<i class="fa-solid fa-pause"></i> PAUSE';
                btn.classList.toggle('bg-amber-600');
                btn.classList.toggle('bg-emerald-600');
                log(sender.isPaused ? "Transfer Paused" : "Transfer Resumed");
            },

            loop: () => {
                if (sender.isComplete) return;

                sender.loopId = requestAnimationFrame(sender.loop);
                
                // Throttle QR generation to ~15 FPS to allow receiver camera to focus
                const now = performance.now();
                if (now - sender.lastRenderTime < 66) return; // 15 FPS
                sender.lastRenderTime = now;

                if (sender.isPaused) return;

                // Priority Logic
                let seqToSend = -1;
                let isFin = false;

                if (sender.state === 'DRAINING') {
                    // Only send FIN
                    isFin = true;
                } else {
                    // 1. High Priority: NACKs
                    if (sender.nacked.size > 0) {
                        seqToSend = sender.nacked.values().next().value;
                        sender.nacked.delete(seqToSend); // Move to inflight
                    } 
                    // 2. Medium Priority: New Packets within Window
                    else if (sender.windowBase < sender.totalChunks) {
                        // Find next unacked packet in window
                        for (let i = 0; i < sender.windowSize; i++) {
                            const candidate = sender.windowBase + i;
                            if (candidate < sender.totalChunks && !sender.acked.has(candidate)) {
                                seqToSend = candidate;
                                break;
                            }
                        }
                    }

                    // 3. Carousel/Keepalive: If window is stalled, rotate oldest unacked
                    if (seqToSend === -1 && sender.windowBase < sender.totalChunks) {
                         // Just retransmit windowBase to poke receiver
                         seqToSend = sender.windowBase;
                    }
                }

                if (sender.state === 'TRANSFER' && sender.acked.size === sender.totalChunks) {
                    sender.state = 'DRAINING';
                    log("All packets ACKed. Entering DRAINING state (sending FIN).", "success");
                    isFin = true;
                }

                // Generate Data String
                // Format: V1|SEQ|TOTAL|B64 or FIN|HASH
                let qrData = '';
                if (isFin) {
                    qrData = `FIN|${sender.file.name}|${sender.file.size}|${sender.totalChunks}`;
                } else if (seqToSend !== -1) {
                    qrData = `1|${seqToSend}|${sender.totalChunks}|${sender.chunks[seqToSend]}`;
                    
                    // Update UI
                    document.getElementById('sender-seq').innerText = seqToSend;
                    document.getElementById('sender-window').innerText = `${sender.windowBase}-${sender.windowBase + sender.windowSize}`;
                }

                if (qrData) {
                    sender.renderQR(qrData);
                }
            },

            renderQR: (text) => {
                sender.qrEl.innerHTML = '';
                // Using QRCode.js
                // We recreate the object to prevent memory leaks/state issues in some versions
                new QRCode(sender.qrEl, {
                    text: text,
                    width: 400,
                    height: 400,
                    colorDark : "#000000",
                    colorLight : "#ffffff",
                    correctLevel : QR_ERROR_LEVEL
                });
            },

            handleControlMsg: (msg) => {
                if (msg.type === 'ack') {
                    // Cumulative ACK or Single ACK logic? 
                    // Let's assume the receiver sends simple ACKs for now to be robust
                    const seq = msg.seq;
                    if (!sender.acked.has(seq)) {
                        sender.acked.add(seq);
                        sender.nacked.delete(seq);
                        sender.updateProgress();
                        sender.advanceWindow();
                    }
                } 
                else if (msg.type === 'nack') {
                    // Receiver explicitly missed these
                    msg.seqs.forEach(s => {
                        if (!sender.acked.has(s)) sender.nacked.add(s);
                    });
                }
                else if (msg.type === 'fin_ack') {
                    sender.finish();
                }
                else if (msg.type === 'hello') {
                    // Handshake, maybe update peer ID for direct comms
                    log("Receiver connected.", "success");
                }
            },

            advanceWindow: () => {
                // Window Base is the smallest number NOT in acked set
                while (sender.acked.has(sender.windowBase) && sender.windowBase < sender.totalChunks) {
                    sender.windowBase++;
                }
                // Adaptive Window: Grow if things are going well (heuristic)
                // Simple AIMD or static for now. Let's keep it safe.
                if (sender.windowSize < WINDOW_MAX_SIZE) sender.windowSize++;
            },

            updateProgress: () => {
                const pct = Math.floor((sender.acked.size / sender.totalChunks) * 100);
                document.getElementById('sender-progress').innerText = `${pct}%`;
                document.getElementById('sender-progress-bar').style.width = `${pct}%`;
            },

            finish: () => {
                if (sender.isComplete) return;
                sender.isComplete = true;
                sender.state = 'COMPLETE';
                cancelAnimationFrame(sender.loopId);
                document.getElementById('sender-complete-overlay').classList.remove('hidden');
                log("Transfer Complete!", "success");
            }
        };

        // --- RECEIVER LOGIC ---
        const receiver = {
            video: null,
            canvas: null,
            ctx: null,
            scanLoopId: null,
            
            chunks: new Map(), // seq -> data
            totalChunks: 0,
            meta: null, // { name, size }
            
            startTime: 0,
            bytesReceived: 0,
            lastScanTime: 0,
            lastDecodedData: null,
            
            // Stats
            frameCount: 0,
            lastStatTime: 0,

            init: () => {
                receiver.video = document.getElementById('video');
                receiver.canvas = document.getElementById('canvas');
                receiver.ctx = receiver.canvas.getContext('2d', { willReadFrequently: true });
                
                // Camera handling
                const camSelect = document.getElementById('camera-select');
                camSelect.addEventListener('change', () => receiver.startCamera(camSelect.value));
                receiver.startCamera('environment');

                // Send Hello if Peer connected
                if (app.conn && app.conn.open) {
                    app.sendControl({ type: 'hello', id: app.peerId });
                }
            },

            startCamera: async (facingMode) => {
                if (receiver.video.srcObject) {
                    receiver.video.srcObject.getTracks().forEach(t => t.stop());
                }
                
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        video: { 
                            facingMode: facingMode,
                            width: { ideal: 1920 }, // Request high res
                            height: { ideal: 1080 } 
                        } 
                    });
                    receiver.video.srcObject = stream;
                    receiver.video.setAttribute("playsinline", true);
                    receiver.video.play();
                    requestAnimationFrame(receiver.scan);
                } catch (e) {
                    log("Camera Access Denied or Error", "error");
                    alert("Camera access required.");
                }
            },

            scan: () => {
                if (receiver.video.readyState === receiver.video.HAVE_ENOUGH_DATA) {
                    const now = performance.now();
                    
                    // Throttle scanning to save CPU and battery
                    if (now - receiver.lastScanTime > (1000 / SCAN_FPS_LIMIT)) {
                        receiver.lastScanTime = now;
                        
                        // 1. Draw video to canvas (Smart Crop / Downscale)
                        // We use a fixed width for processing to ensure consistency regardless of 4k vs 720p cameras
                        const processWidth = 800;
                        const scale = processWidth / receiver.video.videoWidth;
                        const processHeight = receiver.video.videoHeight * scale;

                        receiver.canvas.width = processWidth;
                        receiver.canvas.height = processHeight;
                        
                        receiver.ctx.drawImage(receiver.video, 0, 0, receiver.canvas.width, receiver.canvas.height);
                        
                        // 2. Scan with jsQR
                        const imageData = receiver.ctx.getImageData(0, 0, receiver.canvas.width, receiver.canvas.height);
                        const code = jsQR(imageData.data, imageData.width, imageData.height, {
                            inversionAttempts: "dontInvert",
                        });

                        if (code && code.data) {
                            receiver.handleData(code.data);
                            receiver.drawBox(code.location);
                        }
                        
                        // Stats Update
                        receiver.frameCount++;
                        if (now - receiver.lastStatTime >= 1000) {
                            document.getElementById('rx-fps').innerText = receiver.frameCount;
                            receiver.frameCount = 0;
                            receiver.lastStatTime = now;
                        }
                    }
                }
                receiver.scanLoopId = requestAnimationFrame(receiver.scan);
            },

            drawBox: (loc) => {
                receiver.ctx.beginPath();
                receiver.ctx.lineWidth = 4;
                receiver.ctx.strokeStyle = "#10b981";
                receiver.ctx.moveTo(loc.topLeftCorner.x, loc.topLeftCorner.y);
                receiver.ctx.lineTo(loc.topRightCorner.x, loc.topRightCorner.y);
                receiver.ctx.lineTo(loc.bottomRightCorner.x, loc.bottomRightCorner.y);
                receiver.ctx.lineTo(loc.bottomLeftCorner.x, loc.bottomLeftCorner.y);
                receiver.ctx.lineTo(loc.topLeftCorner.x, loc.topLeftCorner.y);
                receiver.ctx.stroke();
            },

            handleData: (data) => {
                // Debounce exact duplicates to prevent processing logic spam
                // But we MUST allow resending ACK if sender missed it, so we throttle time, not forever
                if (data === receiver.lastDecodedData && (performance.now() - receiver.lastScanTime < 200)) {
                    return;
                }
                receiver.lastDecodedData = data;

                // Protocol Parsing
                // Format: 1|SEQ|TOTAL|B64 or FIN|NAME|SIZE|TOTAL
                const parts = data.split('|');
                
                if (parts[0] === 'FIN') {
                    // FIN packet
                    const name = parts[1];
                    const size = parseInt(parts[2]);
                    const total = parseInt(parts[3]);
                    
                    if (!receiver.meta) receiver.meta = { name, size };
                    
                    // Check if we actually have everything
                    if (receiver.chunks.size === total) {
                        app.sendControl({ type: 'fin_ack' });
                        receiver.completeTransfer();
                    } else {
                        // We are missing stuff despite sender thinking we are done?
                        // This implies state desync. Send NACKs for what we know we miss.
                        // (Usually shouldn't happen with strict window logic, but good safety)
                        receiver.checkMissingAndNack(total);
                    }
                    return;
                }

                if (parts[0] !== '1') return; // Version mismatch

                const seq = parseInt(parts[1]);
                const total = parseInt(parts[2]);
                const payload = parts[3];

                // First packet init
                if (receiver.totalChunks === 0) {
                    receiver.totalChunks = total;
                    receiver.startTime = Date.now();
                    document.getElementById('rx-progress-text').innerText = `0 / ${total} chunks`;
                }

                // Store Data
                if (!receiver.chunks.has(seq)) {
                    receiver.chunks.set(seq, payload);
                    
                    // Update stats
                    // Base64 is ~1.33x size, roughly calculate original bytes
                    const byteEst = payload.length * 0.75; 
                    receiver.bytesReceived += byteEst;
                    
                    // Send ACK
                    app.sendControl({ type: 'ack', seq: seq });
                    
                    receiver.updateUI();
                } else {
                    // Duplicate received, still ACK it because Sender might have lost the previous ACK
                    app.sendControl({ type: 'ack', seq: seq });
                }

                // Every 10 packets or so, check for holes and send NACKs
                // This speeds up recovery in case of selective loss
                if (seq % 10 === 0) {
                    receiver.checkMissingAndNack(seq);
                }
            },

            checkMissingAndNack: (upToSeq) => {
                // Find holes before the current sequence
                const missing = [];
                // Look back a reasonable amount (e.g., 50 packets) to not flood NACKs for whole file
                const startCheck = Math.max(0, upToSeq - 50);
                for (let i = startCheck; i < upToSeq; i++) {
                    if (!receiver.chunks.has(i)) {
                        missing.push(i);
                    }
                }
                if (missing.length > 0) {
                    app.sendControl({ type: 'nack', seqs: missing });
                }
            },

            updateUI: () => {
                const count = receiver.chunks.size;
                const total = receiver.totalChunks;
                const pct = Math.floor((count / total) * 100);
                
                document.getElementById('rx-progress-text').innerText = `${count} / ${total} chunks`;
                document.getElementById('rx-percent').innerText = `${pct}%`;
                document.getElementById('rx-progress-bar').style.width = `${pct}%`;

                // Calculate Speed
                const duration = (Date.now() - receiver.startTime) / 1000;
                if (duration > 1) {
                    const speed = (receiver.bytesReceived / 1024) / duration;
                    document.getElementById('rx-bps').innerText = speed.toFixed(1);
                }

                // Check completion (Early check, before FIN)
                if (count === total && !receiver.isComplete) {
                     // We have everything, we can conceptually finish.
                     // We wait for FIN usually to get filename, but we can trigger ready state.
                     app.sendControl({ type: 'fin_ack' });
                }
            },

            completeTransfer: () => {
                if (receiver.isComplete) return;
                receiver.isComplete = true;
                
                document.getElementById('rx-complete-msg').classList.remove('hidden');
                document.getElementById('rx-filename').innerText = receiver.meta ? receiver.meta.name : "Unknown File";
                
                // Stop camera
                if (receiver.video.srcObject) {
                    receiver.video.srcObject.getTracks().forEach(t => t.stop());
                }
                cancelAnimationFrame(receiver.scanLoopId);
            },

            downloadFile: () => {
                if (!receiver.isComplete) return;

                // Reconstruct File
                // 1. Sort chunks
                const sortedKeys = Array.from(receiver.chunks.keys()).sort((a,b) => a-b);
                
                // 2. Pre-allocate buffer
                // We need to decode base64 to find exact size or just append blobs
                const blobs = [];
                
                for (let key of sortedKeys) {
                    const b64 = receiver.chunks.get(key);
                    const byteCharacters = atob(b64);
                    const byteNumbers = new Array(byteCharacters.length);
                    for (let i = 0; i < byteCharacters.length; i++) {
                        byteNumbers[i] = byteCharacters.charCodeAt(i);
                    }
                    const byteArray = new Uint8Array(byteNumbers);
                    blobs.push(byteArray);
                }

                const blob = new Blob(blobs, { type: "application/octet-stream" });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = receiver.meta ? receiver.meta.name : `optilink_file_${Date.now()}.bin`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            },
            
            reset: () => {
                location.reload();
            }
        };

        // Initialize P2P immediately
        app.initP2P();

    </script>
</body>
</html>
