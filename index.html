<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GhostShare | Secure P2P Link</title>
    
    <!-- Dependencies (CDN) -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>

    <style>
        :root {
            --bg: #000000;
            --fg: #ffffff;
            --dim: #666666;
            --border: #333333;
            --highlight: #ffffff;
            --font-stack: 'SF Mono', 'Segoe UI Mono', 'Roboto Mono', Menlo, monospace;
            --ease: cubic-bezier(0.23, 1, 0.32, 1);
        }

        /* RESET & BASE */
        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; -webkit-tap-highlight-color: transparent; }
        
        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-stack);
            font-size: 14px;
            line-height: 1.5;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow-x: hidden;
        }

        /* LAYOUT UTILS */
        .container {
            max-width: 640px;
            margin: 0 auto;
            width: 100%;
            padding: 20px;
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .flex-row { display: flex; justify-content: space-between; align-items: center; gap: 10px; }
        .flex-col { display: flex; flex-direction: column; gap: 15px; }
        .center { text-align: center; justify-content: center; }
        .hidden { display: none !important; }
        
        /* TYPOGRAPHY */
        h1 { font-size: 18px; font-weight: 700; letter-spacing: -0.5px; text-transform: uppercase; border-bottom: 1px solid var(--border); padding-bottom: 15px; margin-bottom: 20px; }
        h2 { font-size: 14px; font-weight: 600; color: var(--dim); text-transform: uppercase; margin-bottom: 10px; letter-spacing: 1px; }
        p { color: var(--dim); font-size: 13px; margin-bottom: 10px; }
        .mono-stat { font-variant-numeric: tabular-nums; letter-spacing: -0.5px; }

        /* COMPONENTS */
        .card {
            border: 1px solid var(--border);
            background: var(--bg);
            padding: 20px;
            margin-bottom: 20px;
            transition: border-color 0.3s var(--ease);
        }
        .card:hover { border-color: var(--dim); }

        .btn {
            background: var(--fg);
            color: var(--bg);
            border: 1px solid var(--fg);
            padding: 14px;
            font-family: var(--font-stack);
            font-weight: 600;
            font-size: 14px;
            cursor: pointer;
            width: 100%;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            transition: transform 0.1s;
        }
        .btn:active { transform: scale(0.98); }
        .btn:disabled { background: var(--border); border-color: var(--border); color: var(--dim); cursor: not-allowed; }
        .btn.outline { background: transparent; color: var(--fg); }
        .btn.outline:hover { background: rgba(255,255,255,0.1); }
        .btn.danger { border-color: #ff3333; color: #ff3333; background: transparent; }

        input[type="text"] {
            width: 100%;
            background: #0a0a0a;
            border: 1px solid var(--border);
            color: var(--fg);
            padding: 15px;
            font-family: var(--font-stack);
            font-size: 18px;
            text-align: center;
            letter-spacing: 4px;
            text-transform: uppercase;
            margin-bottom: 10px;
        }
        input[type="text"]:focus { border-color: var(--fg); }

        /* SPECIFIC MODULES */
        /* Status Badge */
        .status-dot { width: 8px; height: 8px; background: var(--dim); border-radius: 50%; display: inline-block; margin-right: 8px; }
        .status-dot.active { background: #00ff00; box-shadow: 0 0 10px rgba(0,255,0,0.5); }
        .status-dot.error { background: #ff3333; }

        /* ID Badge */
        .my-id { font-size: 32px; font-weight: 700; letter-spacing: 4px; margin: 10px 0; word-break: break-all; }

        /* QR Area */
        #qr-target { background: white; padding: 10px; display: inline-block; margin: 15px auto; }
        #qr-target img { display: block; }
        
        /* Scanner */
        #reader { width: 100%; border: 1px solid var(--border); overflow: hidden; margin-bottom: 15px; }
        #reader video { object-fit: cover; }

        /* Transfer UI */
        .transfer-item { margin-top: 15px; padding-top: 15px; border-top: 1px dashed var(--border); }
        .progress-track { background: var(--border); height: 4px; width: 100%; margin: 10px 0; overflow: hidden; }
        .progress-fill { background: var(--fg); height: 100%; width: 0%; transition: width 0.2s linear; }
        
        /* Drag Overlay */
        #drag-overlay {
            position: fixed; top: 0; left: 0; right: 0; bottom: 0;
            background: rgba(0,0,0,0.9);
            border: 2px dashed var(--fg);
            z-index: 999;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            pointer-events: none; /* Let events pass through initially */
            opacity: 0;
            transition: opacity 0.2s;
        }
        #drag-overlay.active { opacity: 1; pointer-events: all; }
        .drop-icon { font-size: 48px; margin-bottom: 20px; }

        /* Toast */
        .toast {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            background: var(--fg); color: var(--bg);
            padding: 12px 24px; font-weight: 600;
            opacity: 0; pointer-events: none; transition: opacity 0.3s;
            z-index: 1000; text-align: center; min-width: 200px;
        }
        .toast.show { opacity: 1; }

        @media (max-width: 480px) {
            .container { padding: 15px; }
            .my-id { font-size: 24px; }
        }
    </style>
</head>
<body>

    <!-- DRAG DROP OVERLAY -->
    <div id="drag-overlay">
        <div class="drop-icon">⇩</div>
        <h1>Drop files to send</h1>
    </div>

    <div class="container">
        <!-- HEADER -->
        <header class="flex-row">
            <div>
                GHOSTSHARE <span style="color: var(--dim); font-size: 10px;">v2.0</span>
            </div>
            <div class="flex-row">
                <div id="status-dot" class="status-dot"></div>
                <span id="status-text" class="mono-stat" style="font-size: 10px; text-transform: uppercase;">Initializing</span>
            </div>
        </header>

        <!-- VIEW: IDENTITY -->
        <div id="view-identity" class="card center fade-in">
            <h2>Your Identity</h2>
            <div id="my-id" class="my-id">...</div>
            <p>Scan to connect instantly</p>
            
            <div id="qr-target" class="hidden"></div>

            <div class="flex-row" style="margin-top: 15px;">
                <button class="btn outline" onclick="app.copyId()">Copy ID</button>
                <button class="btn outline" onclick="app.toggleQr()">QR Code</button>
            </div>
        </div>

        <!-- VIEW: CONNECT -->
        <div id="view-connect" class="card fade-in">
            <h2>Establish Link</h2>
            
            <!-- Scanner View -->
            <div id="reader-container" class="hidden">
                <div id="reader"></div>
                <button class="btn outline" onclick="app.stopScanner()" style="margin-bottom: 10px;">Cancel Scan</button>
            </div>

            <!-- Manual Input -->
            <div id="input-container">
                <input type="text" id="peer-id-input" placeholder="PEER ID" maxlength="6" autocomplete="off" autocorrect="off">
                <div class="flex-row">
                    <button class="btn" id="btn-connect" onclick="app.connect()">Connect</button>
                    <button class="btn outline" onclick="app.startScanner()" style="width: auto;" aria-label="Scan QR">
                        <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <path d="M3 7V5a2 2 0 0 1 2-2h2"></path>
                            <path d="M17 3h2a2 2 0 0 1 2 2v2"></path>
                            <path d="M21 17v2a2 2 0 0 1-2 2h-2"></path>
                            <path d="M7 21H5a2 2 0 0 1-2-2v-2"></path>
                            <rect x="7" y="7" width="10" height="10"></rect>
                        </svg>
                    </button>
                </div>
            </div>
        </div>

        <!-- VIEW: TRANSFER ZONE (Hidden until connected) -->
        <div id="view-transfer" class="card hidden fade-in">
            <div class="flex-row">
                <h2>Secure Channel Active</h2>
                <button class="btn outline" style="width: auto; padding: 5px 10px; font-size: 10px;" onclick="app.disconnect()">Disconnect</button>
            </div>
            
            <div class="center" style="border: 2px dashed var(--border); padding: 30px; margin: 20px 0; cursor: pointer;" onclick="document.getElementById('file-input').click()">
                <p><strong>Click to Select</strong> or Drag Files Here</p>
                <input type="file" id="file-input" style="display: none" multiple onchange="app.handleFiles(this.files)">
            </div>

            <div id="transfer-list" class="flex-col">
                <!-- Transfers injected via JS -->
            </div>
        </div>

        <div style="margin-top: auto; text-align: center;">
            <p style="font-size: 10px;">End-to-End Encrypted via WebRTC. No Server Storage.</p>
        </div>
    </div>

    <!-- TOAST NOTIFICATION -->
    <div id="toast" class="toast">Notification</div>

    <script>
        /**
         * GHOSTSHARE CORE LOGIC
         * Architecture: Single Class Controller
         * Protocol: PeerJS (Signaling) -> WebRTC DataChannel (Transfer)
         */

        // CONFIGURATION
        const CONFIG = {
            CHUNK_SIZE: 16 * 1024, // 16KB (Safe for all browsers)
            BUFFER_THRESHOLD: 1024 * 1024, // 1MB Backpressure limit
            ICE_SERVERS: [{ urls: 'stun:stun.l.google.com:19302' }], // Public Google STUN
            APP_URL: 'https://devgna.github.io/' // For QR Links
        };

        class GhostShare {
            constructor() {
                this.peer = null;
                this.conn = null;
                this.myId = null;
                this.pendingConnectId = null; // Store ID from URL if present
                this.transfers = {}; // Map<id, TransferObject>
                this.scanner = null;

                // DOM Elements
                this.dom = {
                    statusDot: document.getElementById('status-dot'),
                    statusText: document.getElementById('status-text'),
                    myId: document.getElementById('my-id'),
                    peerInput: document.getElementById('peer-id-input'),
                    qrTarget: document.getElementById('qr-target'),
                    viewIdentity: document.getElementById('view-identity'),
                    viewConnect: document.getElementById('view-connect'),
                    viewTransfer: document.getElementById('view-transfer'),
                    transferList: document.getElementById('transfer-list'),
                    dragOverlay: document.getElementById('drag-overlay'),
                    toast: document.getElementById('toast'),
                    btnConnect: document.getElementById('btn-connect')
                };

                this.init();
                this.setupDragDrop();
            }

            // --- INITIALIZATION ---

            init() {
                // 1. Generate short ID
                this.myId = Math.random().toString(36).substring(2, 8).toUpperCase();
                this.dom.myId.innerText = this.myId;
                
                // 2. Generate Universal QR Code (URL Format)
                this.generateQr(`${CONFIG.APP_URL}?peer=${this.myId}`);

                // 3. Check for inbound URL deep link (QR Scan via Camera)
                const urlParams = new URLSearchParams(window.location.search);
                const peerParam = urlParams.get('peer');
                
                if (peerParam) {
                    const validId = this.extractPeerId(peerParam); // Basic cleanup
                    if (validId) {
                        this.pendingConnectId = validId;
                        this.notify("Connecting via QR link...");
                    }
                }

                // 4. Init PeerJS
                this.peer = new Peer(this.myId, {
                    debug: 1,
                    config: { iceServers: CONFIG.ICE_SERVERS }
                });

                this.peer.on('open', (id) => {
                    this.setStatus('Ready', 'active');
                    
                    // Handle Pending Auto-Connect
                    if (this.pendingConnectId) {
                        if (this.pendingConnectId === this.myId) {
                            this.notify("Cannot connect to yourself");
                            this.cleanUrl(); // Remove param
                        } else {
                            this.dom.peerInput.value = this.pendingConnectId;
                            this.connect();
                            this.cleanUrl(); // Clean URL after initiating
                        }
                        this.pendingConnectId = null;
                    }
                });

                this.peer.on('connection', (conn) => {
                    if(this.conn) {
                        conn.close(); // Only one peer allowed
                        return;
                    }
                    this.handleConnection(conn);
                });

                this.peer.on('error', (err) => {
                    console.error(err);
                    this.notify(`Error: ${err.type}`);
                    this.setStatus('Error', 'error');
                    this.dom.btnConnect.disabled = false;
                    this.dom.btnConnect.innerText = "Connect";
                });
            }

            // --- QR & URL HELPERS ---

            // Extracts valid Peer ID from raw string or URL
            extractPeerId(input) {
                if (!input) return null;
                let id = null;

                // Attempt to parse as URL first
                try {
                    const url = new URL(input);
                    // Handle query param format ?peer=ID
                    const param = url.searchParams.get('peer');
                    if (param) id = param;
                } catch (e) {
                    // Not a URL, treat as raw ID
                    id = input;
                }

                if (!id) return null;

                // Clean and Validate
                id = id.trim().toUpperCase();
                
                // Allow alphanumeric only, length check to avoid garbage
                if (/^[A-Z0-9]{4,12}$/.test(id)) {
                    return id;
                }
                return null;
            }

            cleanUrl() {
                if (window.history.replaceState) {
                    const clean = window.location.protocol + "//" + window.location.host + window.location.pathname;
                    window.history.replaceState({path: clean}, '', clean);
                }
            }

            // --- CONNECTION HANDLING ---

            connect() {
                // Extract from input using the same robust logic (handles user pasting URL)
                const rawInput = this.dom.peerInput.value;
                const peerId = this.extractPeerId(rawInput);

                if (!peerId) return this.notify("Invalid Peer ID");
                if (peerId === this.myId) return this.notify("Cannot connect to yourself");

                // Update UI to show the parsed ID if they pasted a URL
                this.dom.peerInput.value = peerId;

                this.dom.btnConnect.disabled = true;
                this.dom.btnConnect.innerText = "Connecting...";
                this.setStatus('Connecting...', 'active');

                const conn = this.peer.connect(peerId, { reliable: true });
                this.handleConnection(conn);
            }

            handleConnection(conn) {
                this.conn = conn;
                
                // Connection Events
                conn.on('open', () => {
                    this.setStatus('Connected', 'active');
                    this.notify(`Linked with ${conn.peer}`);
                    this.switchView(true);
                    this.dom.btnConnect.innerText = "Connect"; // Reset for future
                    this.dom.btnConnect.disabled = false;
                });

                conn.on('data', (data) => this.handleData(data));

                conn.on('close', () => {
                    this.notify("Peer Disconnected");
                    this.disconnect();
                });

                conn.on('error', () => {
                    this.notify("Connection Error");
                    this.disconnect();
                });
            }

            disconnect() {
                if (this.conn) {
                    this.conn.close();
                    this.conn = null;
                }
                this.switchView(false);
                this.setStatus('Ready', 'active');
                this.dom.transferList.innerHTML = '';
                this.transfers = {};
            }

            // --- DATA TRANSFER PROTOCOL ---

            handleFiles(fileList) {
                if (!this.conn) return this.notify("Not connected");
                
                Array.from(fileList).forEach(file => {
                    this.startUpload(file);
                });
            }

            async startUpload(file) {
                const transferId = Date.now() + Math.random().toString(36);
                
                // 1. Create UI
                this.createTransferUI(transferId, file.name, file.size, 'upload');

                // 2. Send Metadata
                this.conn.send({
                    type: 'meta',
                    id: transferId,
                    name: file.name,
                    size: file.size,
                    mime: file.type
                });

                // 3. Start Chunked Upload
                const reader = new FileReader();
                let offset = 0;
                
                const readNextChunk = () => {
                    // Check cancellation
                    if (!this.transfers[transferId] || this.transfers[transferId].cancelled) return;

                    // Backpressure Check (Flow Control)
                    if (this.conn.dataChannel.bufferedAmount > CONFIG.BUFFER_THRESHOLD) {
                        setTimeout(readNextChunk, 50); // Wait for buffer to drain
                        return;
                    }

                    const slice = file.slice(offset, offset + CONFIG.CHUNK_SIZE);
                    reader.readAsArrayBuffer(slice);
                };

                reader.onload = (e) => {
                    const chunk = e.target.result;
                    
                    // Send chunk wrapper
                    this.conn.send({
                        type: 'chunk',
                        id: transferId,
                        data: chunk
                    });

                    offset += chunk.byteLength;
                    this.updateProgress(transferId, offset, file.size);

                    if (offset < file.size) {
                        readNextChunk();
                    } else {
                        // Complete
                        this.finishTransfer(transferId);
                    }
                };

                readNextChunk();
            }

            handleData(pkg) {
                // Route packet based on type
                if (pkg.type === 'meta') {
                    this.transfers[pkg.id] = {
                        name: pkg.name,
                        size: pkg.size,
                        mime: pkg.mime,
                        received: 0,
                        buffer: [],
                        startTime: Date.now(),
                        lastUpdate: Date.now(),
                        lastBytes: 0
                    };
                    this.createTransferUI(pkg.id, pkg.name, pkg.size, 'download');
                
                } else if (pkg.type === 'chunk') {
                    const t = this.transfers[pkg.id];
                    if (!t || t.cancelled) return;

                    t.buffer.push(pkg.data);
                    t.received += pkg.data.byteLength;
                    
                    this.updateProgress(pkg.id, t.received, t.size);

                    if (t.received >= t.size) {
                        this.assembleFile(pkg.id);
                    }
                
                } else if (pkg.type === 'cancel') {
                    this.markCancelled(pkg.id);
                }
            }

            assembleFile(id) {
                const t = this.transfers[id];
                const blob = new Blob(t.buffer, { type: t.mime });
                const url = URL.createObjectURL(blob);
                
                // Auto Download
                const a = document.createElement('a');
                a.href = url;
                a.download = t.name;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                
                // Cleanup Memory
                t.buffer = null; // Free array buffer
                this.finishTransfer(id);
                setTimeout(() => URL.revokeObjectURL(url), 30000);
            }

            // --- UI RENDERING ---

            createTransferUI(id, name, size, type) {
                this.transfers[id] = this.transfers[id] || {};
                this.transfers[id].startTime = Date.now();
                this.transfers[id].lastUpdate = Date.now();
                this.transfers[id].lastBytes = 0;

                const div = document.createElement('div');
                div.className = 'transfer-item fade-in';
                div.id = `ui-${id}`;
                div.innerHTML = `
                    <div class="flex-row">
                        <strong>${type === 'upload' ? '↑ SENT' : '↓ RECV'}</strong>
                        <span style="font-size: 12px; overflow: hidden; text-overflow: ellipsis; max-width: 150px;">${name}</span>
                        <span class="mono-stat">${this.formatBytes(size)}</span>
                    </div>
                    <div class="progress-track">
                        <div class="progress-fill" id="bar-${id}"></div>
                    </div>
                    <div class="flex-row">
                        <span id="speed-${id}" class="mono-stat" style="font-size: 10px; color: var(--dim);">Calculating...</span>
                        <button class="btn danger" style="padding: 4px 8px; font-size: 10px; width: auto;" onclick="app.cancelTransfer('${id}')">CANCEL</button>
                    </div>
                `;
                this.dom.transferList.prepend(div);
            }

            updateProgress(id, current, total) {
                const pct = Math.min(100, (current / total) * 100);
                const bar = document.getElementById(`bar-${id}`);
                const speedLabel = document.getElementById(`speed-${id}`);
                
                if (bar) bar.style.width = `${pct}%`;

                // Update Speed every 500ms
                const now = Date.now();
                const t = this.transfers[id];
                if (t && now - t.lastUpdate > 500) {
                    const deltaBytes = current - t.lastBytes;
                    const deltaTime = (now - t.lastUpdate) / 1000;
                    const speed = deltaBytes / deltaTime; // bytes per sec
                    
                    if (speedLabel) speedLabel.innerText = `${this.formatBytes(speed)}/s`;
                    
                    t.lastUpdate = now;
                    t.lastBytes = current;
                }
            }

            finishTransfer(id) {
                const speedLabel = document.getElementById(`speed-${id}`);
                if (speedLabel) {
                    speedLabel.innerText = "Completed";
                    speedLabel.style.color = "#00ff00";
                }
                // Cleanup ref
                if(this.transfers[id]) this.transfers[id].cancelled = true; // prevent further chunks
            }

            cancelTransfer(id) {
                if (this.conn) this.conn.send({ type: 'cancel', id });
                this.markCancelled(id);
            }

            markCancelled(id) {
                if (this.transfers[id]) {
                    this.transfers[id].cancelled = true;
                    this.transfers[id].buffer = null; // Free memory
                }
                const el = document.getElementById(`ui-${id}`);
                if (el) {
                    el.style.opacity = '0.5';
                    const label = document.getElementById(`speed-${id}`);
                    if(label) label.innerText = "Cancelled";
                }
            }

            // --- UTILITIES ---

            switchView(isConnected) {
                if (isConnected) {
                    this.dom.viewIdentity.classList.add('hidden');
                    this.dom.viewConnect.classList.add('hidden');
                    this.dom.viewTransfer.classList.remove('hidden');
                } else {
                    this.dom.viewIdentity.classList.remove('hidden');
                    this.dom.viewConnect.classList.remove('hidden');
                    this.dom.viewTransfer.classList.add('hidden');
                }
            }

            setupDragDrop() {
                // Global Drag events
                window.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    if(this.conn) this.dom.dragOverlay.classList.add('active');
                });

                this.dom.dragOverlay.addEventListener('dragleave', (e) => {
                    e.preventDefault();
                    this.dom.dragOverlay.classList.remove('active');
                });

                this.dom.dragOverlay.addEventListener('drop', (e) => {
                    e.preventDefault();
                    this.dom.dragOverlay.classList.remove('active');
                    if(e.dataTransfer.files.length > 0) {
                        this.handleFiles(e.dataTransfer.files);
                    }
                });
            }

            // QR & Camera
            generateQr(text) {
                this.dom.qrTarget.innerHTML = '';
                try {
                    new QRCode(this.dom.qrTarget, {
                        text: text, width: 128, height: 128,
                        colorDark : "#000000", colorLight : "#ffffff",
                        correctLevel : QRCode.CorrectLevel.L
                    });
                } catch(e) {}
            }

            toggleQr() {
                this.dom.qrTarget.classList.toggle('hidden');
            }

            copyId() {
                navigator.clipboard.writeText(this.myId);
                this.notify("ID Copied");
            }

            startScanner() {
                const readerDiv = document.getElementById('reader-container');
                readerDiv.classList.remove('hidden');
                
                this.scanner = new Html5Qrcode("reader");
                this.scanner.start({ facingMode: "environment" }, { fps: 10, qrbox: 250 }, 
                    (decoded) => {
                        // Use robust extractor for in-app scan
                        const id = this.extractPeerId(decoded);
                        if (id) {
                            this.dom.peerInput.value = id;
                            this.stopScanner();
                            this.notify("QR Detected. Connecting...");
                            this.connect();
                        } else {
                            this.notify("Invalid QR Code");
                        }
                    }
                ).catch(err => this.notify("Camera access denied"));
            }

            stopScanner() {
                if(this.scanner) {
                    this.scanner.stop().then(() => {
                        this.scanner.clear();
                        document.getElementById('reader-container').classList.add('hidden');
                    });
                } else {
                    document.getElementById('reader-container').classList.add('hidden');
                }
            }

            // Helpers
            notify(msg) {
                this.dom.toast.innerText = msg;
                this.dom.toast.classList.add('show');
                setTimeout(() => this.dom.toast.classList.remove('show'), 3000);
            }

            setStatus(text, type) {
                this.dom.statusText.innerText = text;
                this.dom.statusDot.className = `status-dot ${type}`;
            }

            formatBytes(bytes) {
                if (bytes === 0) return '0 B';
                const k = 1024;
                const sizes = ['B', 'KB', 'MB', 'GB'];
                const i = Math.floor(Math.log(bytes) / Math.log(k));
                return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
            }
        }

        // BOOT
        window.app = new GhostShare();

        // Safety Prompt
        window.onbeforeunload = () => window.app.conn ? "Transfer in progress" : undefined;

    </script>
</body>
</html>


