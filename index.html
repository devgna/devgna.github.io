<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>GhostDrop Social</title>
    <!-- Dependencies -->
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/html5-qrcode" type="text/javascript"></script>

    <style>
        :root {
            --bg: #ffffff;
            --fg: #000000;
            --border: #000000;
            --dim: #888888;
            --font-main: system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            --font-mono: ui-monospace, SFMono-Regular, 'SF Mono', Menlo, Consolas, monospace;
        }

        * {
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        body {
            margin: 0;
            padding: 0;
            background: var(--bg);
            color: var(--fg);
            font-family: var(--font-main);
            font-size: 14px;
            height: 100vh;
            display: flex;
            flex-direction: column;
            overflow: hidden;
            overscroll-behavior-y: contain;
        }

        /* Layout Grid */
        #app {
            display: grid;
            grid-template-columns: 300px 1fr;
            grid-template-rows: auto 1fr;
            height: 100%;
            width: 100%;
        }

        /* Mobile Layout Override */
        @media (max-width: 768px) {
            #app {
                display: flex;
                flex-direction: column;
            }
            .desktop-only { display: none !important; }
            .mobile-only { display: flex !important; }
            #sidebar { 
                display: none; 
                flex: 1;
                border-right: none; 
            }
            #main-panel { 
                display: none; 
                flex: 1;
            }
            #sidebar.active, #main-panel.active { display: flex; }
        }

        /* Common UI Elements */
        .border-bottom { border-bottom: 1px solid var(--border); }
        .border-right { border-right: 1px solid var(--border); }
        .border-top { border-top: 1px solid var(--border); }
        .border-all { border: 1px solid var(--border); }

        .btn {
            background: var(--bg);
            color: var(--fg);
            border: 1px solid var(--border);
            padding: 8px 16px;
            cursor: pointer;
            font-family: var(--font-mono);
            font-size: 12px;
            text-transform: uppercase;
            border-radius: 0;
            user-select: none;
        }
        .btn:hover { background: #eee; }
        .btn:active { background: var(--fg); color: var(--bg); }
        .btn:disabled { color: var(--dim); border-color: var(--dim); cursor: not-allowed; }
        .btn-block { width: 100%; display: block; }
        .btn-small { padding: 4px 8px; font-size: 10px; }

        .input {
            border: 1px solid var(--border);
            padding: 8px;
            font-family: var(--font-mono);
            width: 100%;
            border-radius: 0;
            outline: none;
            background: var(--bg);
            color: var(--fg);
        }
        .input:focus { border-width: 2px; padding: 7px; }

        /* Sidebar */
        #sidebar {
            background: var(--bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .user-card {
            padding: 12px;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
        }
        .user-card:hover { background: #f5f5f5; }
        .user-card.active { background: var(--fg); color: var(--bg); }
        .user-card.active .status-dot { border: 1px solid var(--bg); }

        .avatar {
            width: 32px;
            height: 32px;
            border: 1px solid var(--border);
            background: #eee;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            background: var(--dim);
            border: 1px solid transparent;
        }
        .status-dot.online { background: #000; }
        .user-card.active .status-dot.online { background: #fff; }

        /* Main Panel */
        #main-panel {
            background: var(--bg);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            position: relative;
        }

        #chat-history {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .message {
            max-width: 80%;
            border: 1px solid var(--border);
            padding: 8px 12px;
            font-family: var(--font-mono);
            font-size: 12px;
            word-break: break-all;
        }
        .msg-in { align-self: flex-start; background: #fff; }
        .msg-out { align-self: flex-end; background: #f0f0f0; }
        .msg-sys { align-self: center; border: none; color: var(--dim); font-style: italic; }

        /* Input Area */
        #input-area {
            padding: 12px;
            display: flex;
            gap: 8px;
        }

        /* Mobile Tabs */
        #mobile-tabs {
            display: none;
            height: 50px;
        }
        .tab-btn {
            flex: 1;
            border: none;
            border-top: 1px solid var(--border);
            background: var(--bg);
            font-weight: bold;
        }
        .tab-btn.active {
            background: var(--fg);
            color: var(--bg);
        }

        /* Modals */
        .modal-overlay {
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(255,255,255,0.95);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        .modal-overlay.open { display: flex; }
        .modal-box {
            background: var(--bg);
            border: 2px solid var(--border);
            padding: 24px;
            width: 90%;
            max-width: 400px;
        }

        /* Toast */
        #toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 2000;
            pointer-events: none;
        }
        .toast {
            background: var(--fg);
            color: var(--bg);
            padding: 8px 16px;
            font-family: var(--font-mono);
            font-size: 12px;
            min-width: 200px;
            border: 1px solid var(--bg);
        }

        /* Helpers */
        .mono { font-family: var(--font-mono); }
        .text-sm { font-size: 12px; }
        .hidden { display: none; }
        .mt-2 { margin-top: 8px; }
        .mb-4 { margin-bottom: 16px; }
        .flex { display: flex; }
        .gap-2 { gap: 8px; }

        /* QR Reader */
        #reader { width: 100%; border: 1px solid var(--border); }
    </style>
</head>
<body>

<div id="app">
    <!-- Sidebar -->
    <aside id="sidebar" class="border-right active">
        <div class="border-bottom" style="padding: 16px;">
            <div style="font-weight: bold; font-size: 16px;">GHOST DROP</div>
            <div id="my-id" class="mono text-sm mt-2">Connecting...</div>
            <div class="mt-2 flex gap-2">
                <button class="btn btn-small" onclick="app.showQR()">Show QR</button>
                <button class="btn btn-small" onclick="app.startScan()">Scan QR</button>
            </div>
        </div>
        
        <div style="padding: 8px;" class="border-bottom">
            <div class="flex gap-2">
                <input type="text" id="add-friend-id" class="input" placeholder="Peer ID" autocomplete="off">
                <button class="btn" onclick="app.addFriendInput()">ADD</button>
            </div>
        </div>

        <div style="flex: 1; overflow-y: auto; -webkit-overflow-scrolling: touch;">
            <div id="friends-list"></div>
        </div>
    </aside>

    <!-- Main Panel -->
    <main id="main-panel">
        <div class="border-bottom" style="padding: 12px; display: flex; justify-content: space-between; align-items: center;">
            <div id="chat-header" class="mono font-bold">SELECT FRIEND</div>
            <div id="status-indicator" class="text-sm mono dim">OFFLINE</div>
        </div>

        <div id="chat-history"></div>

        <div id="input-area" class="border-top">
            <input type="file" id="file-input" class="hidden" onchange="transfer.handleFileSelect(this)">
            <button id="btn-file" class="btn" onclick="document.getElementById('file-input').click()" disabled>FILE</button>
            <input type="text" id="msg-input" class="input" placeholder="Message..." onkeypress="if(event.key==='Enter') app.sendMsg()" autocomplete="off" disabled>
            <button id="btn-send" class="btn" onclick="app.sendMsg()" disabled>SEND</button>
        </div>
    </main>

    <!-- Mobile Tabs -->
    <div id="mobile-tabs" class="mobile-only">
        <button class="tab-btn active" onclick="app.switchTab('friends')">FRIENDS</button>
        <button class="tab-btn" onclick="app.switchTab('chat')">CHAT</button>
    </div>
</div>

<!-- Modals -->
<div id="modal-qr" class="modal-overlay">
    <div class="modal-box">
        <h3 class="mono" style="margin-top:0">IDENTITY</h3>
        <div id="qrcode" style="display: flex; justify-content: center; margin: 16px 0;"></div>
        <button class="btn btn-block" onclick="app.closeModal('modal-qr')">CLOSE</button>
    </div>
</div>

<div id="modal-scan" class="modal-overlay">
    <div class="modal-box">
        <h3 class="mono" style="margin-top:0">SCAN FRIEND</h3>
        <div id="reader"></div>
        <button class="btn btn-block mt-2" onclick="app.stopScan()">CANCEL</button>
    </div>
</div>

<div id="modal-transfer" class="modal-overlay">
    <div class="modal-box">
        <h3 class="mono" style="margin-top:0">INCOMING FILE</h3>
        <div id="transfer-details" class="mono text-sm mb-4"></div>
        <div class="flex gap-2">
            <button class="btn btn-block" onclick="transfer.respond(true)">ACCEPT</button>
            <button class="btn btn-block" onclick="transfer.respond(false)">REJECT</button>
        </div>
    </div>
</div>

<div id="toast-container"></div>

<script>
/**
 * GHOST DROP SOCIAL - HARDENED PRODUCTION VERSION
 * Fixes: Backpressure, Memory Safety, WakeLock, Protocol, Scanner, Mobile Input
 */

// --- 1. State & Constants ---
const CHUNK_SIZE = 16 * 1024; // 16KB strict chunking
const BUFFER_THRESHOLD = 64 * 1024; // 64KB backpressure threshold

const state = {
    peer: null,
    id: localStorage.getItem('gd_id'),
    friends: JSON.parse(localStorage.getItem('gd_friends') || '{}'),
    activePeer: null,
    conns: {}, // peerId -> DataConnection
    transfers: {}, // peerId -> TransferState
    scanner: null
};

// --- 2. Wake Lock Manager ---
const wakeLock = {
    sentinel: null,
    count: 0,
    async request() {
        this.count++;
        if (!this.sentinel && 'wakeLock' in navigator) {
            try { this.sentinel = await navigator.wakeLock.request('screen'); } 
            catch(e) { console.warn('WakeLock denied', e); }
        }
    },
    release() {
        if (this.count > 0) this.count--;
        if (this.count === 0 && this.sentinel) {
            this.sentinel.release().catch(() => {});
            this.sentinel = null;
        }
    }
};

// --- 3. Utilities ---
const utils = {
    genId: () => {
        const id = 'ghost-' + Math.floor(Math.random() * 9000 + 1000);
        localStorage.setItem('gd_id', id);
        return id;
    },
    toast: (msg) => {
        const c = document.getElementById('toast-container');
        const d = document.createElement('div');
        d.className = 'toast';
        d.innerText = msg;
        c.appendChild(d);
        setTimeout(() => d.remove(), 4000);
    },
    formatSize: (b) => {
        if (b === 0) return '0 B';
        const u = ['B', 'KB', 'MB', 'GB'];
        let i = 0;
        while(b >= 1024 && i < u.length - 1) { b /= 1024; i++; }
        return b.toFixed(1) + u[i];
    },
    notify: (title, body) => {
        if (!('Notification' in window)) return;
        if (Notification.permission === 'granted') new Notification(title, { body });
        else if (Notification.permission !== 'denied') Notification.requestPermission();
    },
    revoke: (url) => {
        if (url) setTimeout(() => URL.revokeObjectURL(url), 60000); // Clean up after 1 min
    }
};

if (!state.id) state.id = utils.genId();

// --- 4. Network Layer ---
const net = {
    init: () => {
        state.peer = new Peer(state.id, { 
            debug: 1,
            config: { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }
        });
        
        state.peer.on('open', (id) => {
            document.getElementById('my-id').innerText = id;
            new QRCode(document.getElementById("qrcode"), { text: id, width: 128, height: 128 });
            net.pingFriends();
            if ('Notification' in window) Notification.requestPermission();
        });

        state.peer.on('connection', (conn) => {
            net.bindConn(conn);
        });

        state.peer.on('error', (err) => {
            utils.toast(`Net Error: ${err.type}`);
        });

        state.peer.on('disconnected', () => {
            utils.toast('Disconnected from signaling server. Reconnecting...');
            state.peer.reconnect();
        });
    },

    connect: (id) => {
        if (state.conns[id] && state.conns[id].open) return state.conns[id];
        const conn = state.peer.connect(id, { reliable: true });
        net.bindConn(conn);
        return conn;
    },

    bindConn: (conn) => {
        if (state.conns[conn.peer]) {
            state.conns[conn.peer].close(); // Close existing to replace
        }
        state.conns[conn.peer] = conn;

        conn.on('open', () => {
            // CRITICAL: Set backpressure threshold explicitly
            if (conn.dataChannel) {
                conn.dataChannel.bufferedAmountLowThreshold = BUFFER_THRESHOLD;
            }

            if (state.friends[conn.peer]) {
                const wasOffline = !state.friends[conn.peer].online;
                state.friends[conn.peer].online = true;
                app.renderFriends();
                if (wasOffline) utils.notify('GhostDrop', `${state.friends[conn.peer].nick || conn.peer} is online`);
            }
            if (state.activePeer === conn.peer) app.updateHeader();
        });

        conn.on('data', (data) => {
            if (data.constructor === ArrayBuffer || data instanceof Uint8Array) {
                transfer.receiveChunk(conn.peer, data);
            } else {
                transfer.handleMsg(conn.peer, data);
            }
        });

        conn.on('close', () => {
            net.cleanup(conn.peer);
        });

        conn.on('error', () => {
            net.cleanup(conn.peer);
        });
    },

    cleanup: (peerId) => {
        if (state.friends[peerId]) {
            state.friends[peerId].online = false;
            app.renderFriends();
        }
        
        // Clean up active transfers on disconnect
        if (state.transfers[peerId]) {
            transfer.cleanup(peerId);
            utils.toast(`Connection lost with ${peerId}`);
        }

        delete state.conns[peerId];
        if (state.activePeer === peerId) app.updateHeader();
    },

    pingFriends: () => {
        Object.keys(state.friends).forEach(id => {
            net.connect(id);
        });
    }
};

// --- 5. Transfer Engine (Hardened) ---
const transfer = {
    pendingMeta: null,
    
    // --- SENDER LOGIC ---
    sendFile: async (file) => {
        if (!state.activePeer) return;
        const conn = state.conns[state.activePeer];
        if (!conn || !conn.open) return utils.toast('Peer disconnected');
        if (state.transfers[state.activePeer]) return utils.toast('Transfer already in progress');

        const tid = Date.now().toString(36);
        state.transfers[state.activePeer] = {
            role: 'sender',
            file: file,
            offset: 0,
            tid: tid
        };

        conn.send({
            type: 'HEADER',
            name: file.name,
            size: file.size,
            mime: file.type,
            tid: tid
        });

        ui.addSysMsg(`Offering: ${file.name}`);
    },

    startStream: async (peerId) => {
        const t = state.transfers[peerId];
        if (!t || t.role !== 'sender') return;
        
        const conn = state.conns[peerId];
        if (!conn || !conn.open) {
            transfer.cleanup(peerId);
            return;
        }

        wakeLock.request();
        ui.addSysMsg(`Sending ${t.file.name}...`);
        
        const file = t.file;
        const reader = new FileReader();

        const readNextChunk = async () => {
            if (!state.transfers[peerId]) return; // Cancelled
            if (t.offset >= file.size) {
                ui.addSysMsg(`Transfer complete.`);
                transfer.cleanup(peerId);
                return;
            }

            // BACKPRESSURE CHECK
            if (conn.dataChannel.bufferedAmount > BUFFER_THRESHOLD) {
                // Wait for 'bufferedamountlow' event
                await new Promise(resolve => {
                    const handler = () => {
                        conn.dataChannel.removeEventListener('bufferedamountlow', handler);
                        resolve();
                    };
                    conn.dataChannel.addEventListener('bufferedamountlow', handler, { once: true });
                    // Fallback safety timeout if event misses (rare but possible)
                    setTimeout(() => {
                        conn.dataChannel.removeEventListener('bufferedamountlow', handler);
                        resolve();
                    }, 1000); 
                });
            }

            const slice = file.slice(t.offset, t.offset + CHUNK_SIZE);
            reader.readAsArrayBuffer(slice);
        };

        reader.onload = (e) => {
            try {
                conn.send(e.target.result);
                t.offset += e.target.result.byteLength;
                readNextChunk();
            } catch(err) {
                console.error('Send error', err);
                transfer.cleanup(peerId);
                utils.toast('Transfer error');
            }
        };
        
        reader.onerror = () => {
            utils.toast('File read error');
            transfer.cleanup(peerId);
        };

        readNextChunk();
    },

    // --- RECEIVER LOGIC ---
    handleMsg: (peerId, msg) => {
        switch (msg.type) {
            case 'HEADER':
                if (transfer.pendingMeta) {
                    // Busy, auto-reject
                    const conn = state.conns[peerId];
                    if(conn) conn.send({ type: 'REJECT', tid: msg.tid });
                    return;
                }
                transfer.pendingMeta = { ...msg, peer: peerId };
                const nick = state.friends[peerId]?.nick || peerId.substring(0,8);
                document.getElementById('transfer-details').innerText = 
                    `From: ${nick}\nFile: ${msg.name}\nSize: ${utils.formatSize(msg.size)}`;
                document.getElementById('modal-transfer').classList.add('open');
                break;
            case 'ACK':
                if (state.transfers[peerId]?.tid === msg.tid) {
                    transfer.startStream(peerId);
                }
                break;
            case 'REJECT':
                utils.toast('Transfer rejected');
                transfer.cleanup(peerId);
                break;
            case 'CHAT':
                if (state.activePeer === peerId) ui.addChat(msg.text, false);
                else utils.toast(`Msg from ${state.friends[peerId]?.nick || 'Unknown'}`);
                break;
        }
    },

    respond: async (accept) => {
        const meta = transfer.pendingMeta;
        if (!meta) return;
        
        document.getElementById('modal-transfer').classList.remove('open');
        transfer.pendingMeta = null;
        
        const conn = state.conns[meta.peer];
        if (!conn || !conn.open) return utils.toast('Sender disconnected');
        
        if (accept) {
            // Try to use File System Access API for zero-memory download if available
            let fileHandle = null;
            if (window.showSaveFilePicker) {
                try {
                    fileHandle = await window.showSaveFilePicker({ suggestedName: meta.name });
                } catch(e) {
                    // User cancelled picker, treat as reject
                    conn.send({ type: 'REJECT', tid: meta.tid });
                    return;
                }
            }

            state.transfers[meta.peer] = {
                role: 'receiver',
                meta: meta,
                received: 0,
                chunks: [], // Fallback buffer
                fileHandle: fileHandle, // Stream handle
                writable: fileHandle ? await fileHandle.createWritable() : null,
                tid: meta.tid
            };
            
            wakeLock.request();
            conn.send({ type: 'ACK', tid: meta.tid });
            ui.addSysMsg(`Receiving ${meta.name}...`);
        } else {
            conn.send({ type: 'REJECT', tid: meta.tid });
        }
    },

    receiveChunk: async (peerId, buf) => {
        const t = state.transfers[peerId];
        if (!t || t.role !== 'receiver') return;

        // Ensure buffer is ArrayBuffer
        const data = buf instanceof Uint8Array ? buf.buffer : buf;

        try {
            if (t.writable) {
                // Stream directly to disk
                await t.writable.write(data);
            } else {
                // Fallback: Accumulate in memory (Mobile/Firefox)
                t.chunks.push(data);
            }
            
            t.received += data.byteLength;

            if (t.received >= t.meta.size) {
                transfer.finalize(peerId);
            }
        } catch(e) {
            console.error('Write error', e);
            utils.toast('Write error');
            transfer.cleanup(peerId);
        }
    },

    finalize: async (peerId) => {
        const t = state.transfers[peerId];
        let url = null;
        
        try {
            if (t.writable) {
                await t.writable.close();
                ui.addSysMsg(`Saved: ${t.meta.name}`);
            } else {
                const blob = new Blob(t.chunks, { type: t.meta.mime });
                url = URL.createObjectURL(blob);
                ui.addSysMsg(`Received: ${t.meta.name}`);
                
                // Manual Download Trigger for Blob
                transfer.renderPreview(peerId, t.meta, url);
                utils.revoke(url);
            }
        } catch(e) {
            console.error('Finalize error', e);
        }
        
        transfer.cleanup(peerId);
    },

    renderPreview: (peerId, meta, url) => {
        const div = document.createElement('div');
        div.className = 'message msg-in border-all';
        div.innerHTML = `<div class="mono font-bold mb-4">READY: ${meta.name}</div>`;
        
        if (meta.mime.startsWith('image/')) {
            div.innerHTML += `<img src="${url}" style="max-width:100%; border:1px solid #000; display:block; margin-bottom:8px">`;
        } else if (meta.mime.startsWith('video/')) {
            div.innerHTML += `<video src="${url}" controls style="width:100%; display:block; margin-bottom:8px"></video>`;
        }
        
        div.innerHTML += `<a href="${url}" download="${meta.name}" class="btn btn-block" style="text-align:center; text-decoration:none;">SAVE TO DISK</a>`;
        document.getElementById('chat-history').appendChild(div);
        div.scrollIntoView();
    },

    cleanup: (peerId) => {
        const t = state.transfers[peerId];
        if (t) {
            // Close writable if open and error occurred
            if (t.writable) t.writable.abort().catch(()=>{});
            t.chunks = null; // Release memory
        }
        delete state.transfers[peerId];
        wakeLock.release();
    },

    handleFileSelect: (input) => {
        if (input.files.length) transfer.sendFile(input.files[0]);
        input.value = '';
    }
};

// --- 6. UI Controller ---
const app = {
    init: () => {
        app.renderFriends();
        
        // Safe Touch Handling
        document.body.addEventListener('touchmove', (e) => {
            // Allow scroll only in scrollable areas
            if (!e.target.closest('#chat-history') && 
                !e.target.closest('#friends-list') &&
                !e.target.closest('.modal-box')) {
                e.preventDefault();
            }
        }, { passive: false });
    },

    renderFriends: () => {
        const list = document.getElementById('friends-list');
        list.innerHTML = '';
        Object.keys(state.friends).forEach(id => {
            const f = state.friends[id];
            const el = document.createElement('div');
            el.className = `user-card border-bottom ${state.activePeer === id ? 'active' : ''}`;
            el.onclick = () => app.selectPeer(id);
            el.innerHTML = `
                <img src="https://api.dicebear.com/7.x/identicon/svg?seed=${id}" class="avatar">
                <div style="flex:1">
                    <div class="mono font-bold">${f.nick || 'Unknown'}</div>
                    <div class="mono text-sm dim">${id}</div>
                </div>
                <div class="status-dot ${f.online ? 'online' : ''}"></div>
            `;
            list.appendChild(el);
        });
    },

    selectPeer: (id) => {
        state.activePeer = id;
        app.renderFriends();
        app.updateHeader();
        document.getElementById('chat-history').innerHTML = '';
        
        // UI State
        const conn = state.conns[id];
        const ready = conn && conn.open;
        app.toggleInputs(ready);

        // Connect if needed
        if (!conn || !conn.open) {
            net.connect(id);
            // Inputs remain disabled until 'open' event fires
        }

        if (window.innerWidth <= 768) app.switchTab('chat');
    },

    updateHeader: () => {
        if (!state.activePeer) return;
        const f = state.friends[state.activePeer];
        const conn = state.conns[state.activePeer];
        document.getElementById('chat-header').innerText = f.nick || state.activePeer;
        const statusEl = document.getElementById('status-indicator');
        const ready = conn && conn.open;
        
        statusEl.innerText = ready ? 'ONLINE' : 'OFFLINE';
        statusEl.style.color = ready ? 'black' : '#888';
        app.toggleInputs(ready);
    },

    toggleInputs: (enabled) => {
        document.getElementById('msg-input').disabled = !enabled;
        document.getElementById('btn-send').disabled = !enabled;
        document.getElementById('btn-file').disabled = !enabled;
    },

    addFriendInput: () => {
        const input = document.getElementById('add-friend-id');
        const id = input.value.trim();
        if (id && id !== state.id) {
            state.friends[id] = { nick: 'Friend', online: false };
            localStorage.setItem('gd_friends', JSON.stringify(state.friends));
            app.renderFriends();
            net.connect(id);
            input.value = '';
        }
    },

    sendMsg: () => {
        const input = document.getElementById('msg-input');
        const text = input.value.trim();
        if (!text || !state.activePeer) return;
        
        const conn = state.conns[state.activePeer];
        if (conn && conn.open) {
            conn.send({ type: 'CHAT', text });
            ui.addChat(text, true);
            input.value = '';
        } else {
            utils.toast('Not connected');
        }
    },

    showQR: () => document.getElementById('modal-qr').classList.add('open'),
    closeModal: (id) => document.getElementById(id).classList.remove('open'),

    // QR Scanning - Robust Implementation
    startScan: () => {
        document.getElementById('modal-scan').classList.add('open');
        
        // Prevent multiple instances
        if (state.scanner) return;

        state.scanner = new Html5Qrcode("reader");
        const config = { fps: 10, qrbox: { width: 250, height: 250 } };
        
        state.scanner.start({ facingMode: "environment" }, config, 
            (decodedText) => {
                app.stopScan();
                document.getElementById('add-friend-id').value = decodedText;
                app.addFriendInput();
            },
            (err) => { /* ignore frame errors */ }
        ).catch(err => {
            console.error(err);
            utils.toast('Camera access denied or error');
            app.stopScan();
        });
    },

    stopScan: () => {
        if (state.scanner) {
            state.scanner.stop().then(() => {
                state.scanner.clear();
                state.scanner = null;
            }).catch(err => {
                console.error('Stop failed', err);
                state.scanner = null;
            });
        }
        app.closeModal('modal-scan');
    },

    switchTab: (tab) => {
        const sidebar = document.getElementById('sidebar');
        const main = document.getElementById('main-panel');
        const btns = document.querySelectorAll('.tab-btn');
        
        if (tab === 'friends') {
            sidebar.classList.add('active');
            main.classList.remove('active');
            btns[0].classList.add('active');
            btns[1].classList.remove('active');
        } else {
            sidebar.classList.remove('active');
            main.classList.add('active');
            btns[0].classList.remove('active');
            btns[1].classList.add('active');
        }
    }
};

const ui = {
    addChat: (text, self) => {
        const h = document.getElementById('chat-history');
        const d = document.createElement('div');
        d.className = `message ${self ? 'msg-out' : 'msg-in'}`;
        // Safe linkify
        const link = text.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;')
                         .replace(/(https?:\/\/[^\s]+)/g, '<a href="$1" target="_blank">$1</a>');
        d.innerHTML = link;
        h.appendChild(d);
        d.scrollIntoView();
    },
    addSysMsg: (text) => {
        const h = document.getElementById('chat-history');
        const d = document.createElement('div');
        d.className = 'message msg-sys';
        d.innerText = text;
        h.appendChild(d);
        d.scrollIntoView();
    }
};

// Bootstrap
window.onload = () => {
    net.init();
    app.init();
};
</script>
</body>
</html>


