<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>GhostShare | Anonymous P2P Transfer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --bg: #000000;
            --fg: #ffffff;
            --dim: #444444;
            --accent: #ffffff;
            --err: #ff3333;
            --font-mono: 'Courier New', Courier, monospace;
        }

        * { box-sizing: border-box; margin: 0; padding: 0; outline: none; }
        
        body {
            background-color: var(--bg);
            color: var(--fg);
            font-family: var(--font-mono);
            line-height: 1.5;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 1rem;
        }

        /* Typography */
        h1, h2, h3 { font-weight: normal; text-transform: uppercase; letter-spacing: 1px; }
        h1 { font-size: 1.5rem; border-bottom: 2px solid var(--fg); padding-bottom: 0.5rem; margin-bottom: 2rem; }
        p { margin-bottom: 1rem; font-size: 0.9rem; }
        small { color: #888; display: block; margin-top: 0.5rem; font-size: 0.75rem; }

        /* Layout */
        .container { max-width: 600px; margin: 0 auto; width: 100%; }
        .hidden { display: none !important; }
        .fade-in { animation: fadeIn 0.3s ease-in; }

        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Components */
        .btn {
            background: transparent;
            color: var(--fg);
            border: 1px solid var(--fg);
            padding: 12px 20px;
            font-family: var(--font-mono);
            cursor: pointer;
            width: 100%;
            margin-bottom: 1rem;
            text-transform: uppercase;
            transition: all 0.2s;
            font-size: 1rem;
        }
        .btn:hover { background: var(--fg); color: var(--bg); }
        .btn:disabled { border-color: var(--dim); color: var(--dim); cursor: not-allowed; }
        .btn-small { width: auto; padding: 5px 10px; font-size: 0.8rem; margin: 0; }

        .card { border: 1px solid var(--dim); padding: 1.5rem; margin-bottom: 1.5rem; position: relative; }
        
        .input-group { margin-bottom: 1rem; }
        input[type="text"] {
            width: 100%;
            background: #111;
            border: 1px solid var(--dim);
            color: var(--fg);
            padding: 12px;
            font-family: var(--font-mono);
            font-size: 1.2rem;
            text-align: center;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .qr-container { 
            background: white; 
            padding: 10px; 
            display: inline-block; 
            margin: 1rem 0;
            border-radius: 4px;
        }
        .qr-container canvas { display: block; }

        /* ID Badge */
        .id-badge {
            font-size: 2rem;
            letter-spacing: 3px;
            border: 1px dashed var(--dim);
            padding: 1rem;
            margin: 1rem 0;
            word-break: break-all;
            background: #111;
        }

        /* File Transfer UI */
        .progress-bar {
            height: 4px;
            background: var(--dim);
            margin-top: 0.5rem;
            width: 100%;
            position: relative;
        }
        .progress-fill {
            height: 100%;
            background: var(--fg);
            width: 0%;
            transition: width 0.1s linear;
        }

        .status-badge {
            display: inline-block;
            padding: 2px 6px;
            border: 1px solid var(--fg);
            font-size: 0.7rem;
            text-transform: uppercase;
            margin-left: 0.5rem;
        }
        .status-connected { background: var(--fg); color: var(--bg); }
        .status-disconnected { border-color: var(--dim); color: var(--dim); }

        .toast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: var(--fg);
            color: var(--bg);
            padding: 10px 20px;
            border-radius: 4px;
            font-size: 0.8rem;
            z-index: 100;
        }

        /* Utilities */
        .flex-row { display: flex; justify-content: space-between; align-items: center; }
        
        /* Mobile specific */
        @media (max-width: 480px) {
            h1 { font-size: 1.2rem; }
            .card { padding: 1rem; }
            .id-badge { font-size: 1.5rem; }
        }
    </style>
</head>
<body>

<div class="container">
    <header class="flex-row">
        <h1>GhostShare</h1>
        <div id="connectionStatus" class="status-badge status-disconnected">Disconnected</div>
    </header>

    <!-- VIEW: SETUP -->
    <div id="view-setup" class="fade-in">
        <div class="card" style="text-align: center;">
            <p>YOUR ID</p>
            <div id="my-id-display" class="id-badge">...</div>
            <small>Share this ID with your peer</small>
            
            <div id="qr-container" class="qr-container hidden"></div>
            
            <div style="margin-top: 1rem;">
                <button class="btn btn-small" onclick="app.copyId()">Copy ID</button>
                <button class="btn btn-small" onclick="app.toggleQR()">Show QR</button>
            </div>
        </div>

        <div class="card">
            <p>CONNECT TO PEER</p>
            <div class="input-group">
                <input type="text" id="peer-id-input" placeholder="ENTER PEER ID" maxlength="6">
            </div>
            <button class="btn" id="connect-btn" onclick="app.connectToPeer()">Connect</button>
            <small style="text-align: center;">Connection establishes a direct P2P tunnel.</small>
        </div>

        <div style="margin-top: 2rem; text-align: center; font-size: 0.8rem; color: #666;">
            <p>Files are transferred directly between devices.</p>
            <p>No servers. No history.</p>
        </div>
    </div>

    <!-- VIEW: TRANSFER -->
    <div id="view-transfer" class="hidden fade-in">
        <div class="card">
            <h3>Send File</h3>
            <input type="file" id="fileInput" style="display: none" onchange="app.handleFileSelect(this)">
            <button class="btn" onclick="document.getElementById('fileInput').click()">Select File</button>
            <small>Supports any file type. Secure P2P Pipeline.</small>
        </div>

        <div id="transfers-list">
            <!-- Transfers injected here -->
        </div>
    </div>

</div>

<script>
/**
 * GHOSTSHARE 2.0
 * Uses PeerJS for lightweight signaling (free seeding) to enable Short ID connections.
 * Data transfer remains strictly Peer-to-Peer via WebRTC DataChannels.
 */

const CHUNK_SIZE = 16384; // 16KB chunks for reliable progress tracking

// Utility: Visual toast
function showToast(msg) {
    const el = document.createElement('div');
    el.className = 'toast fade-in';
    el.textContent = msg;
    document.body.appendChild(el);
    setTimeout(() => el.remove(), 3000);
}

// Utility: Byte formatting
function formatBytes(bytes, decimals = 2) {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

class GhostShare {
    constructor() {
        this.peer = null;
        this.conn = null;
        this.myId = '';
        this.transfers = {}; // id -> transferObj
        
        this.el = {
            status: document.getElementById('connectionStatus'),
            myId: document.getElementById('my-id-display'),
            peerInput: document.getElementById('peer-id-input'),
            qr: document.getElementById('qr-container'),
            transfersList: document.getElementById('transfers-list'),
            connectBtn: document.getElementById('connect-btn')
        };

        this.initPeer();
    }

    // --- INITIALIZATION & ID GENERATION ---

    generateShortId() {
        // Generate a random 6-character alphanumeric ID
        return Math.random().toString(36).substr(2, 6).toUpperCase();
    }

    initPeer() {
        this.myId = this.generateShortId();
        this.el.myId.textContent = this.myId;
        this.generateQR(this.myId);

        // Initialize PeerJS with public free signaling server
        this.peer = new Peer(this.myId, {
            debug: 2,
            config: {
                iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]
            }
        });

        this.peer.on('open', (id) => {
            console.log('My ID:', id);
            this.el.status.textContent = 'Ready';
        });

        this.peer.on('connection', (conn) => {
            this.handleConnection(conn);
        });

        this.peer.on('error', (err) => {
            console.error(err);
            if (err.type === 'peer-unavailable') {
                showToast("Peer ID not found or offline.");
                this.resetUI();
            } else {
                showToast("Connection Error: " + err.type);
            }
        });
    }

    // --- CONNECTION HANDLING ---

    connectToPeer() {
        const peerId = this.el.peerInput.value.trim().toUpperCase();
        if (!peerId) return showToast("Enter a Peer ID");
        if (peerId === this.myId) return showToast("Cannot connect to yourself");

        this.el.connectBtn.disabled = true;
        this.el.connectBtn.textContent = "Connecting...";

        const conn = this.peer.connect(peerId, {
            reliable: true
        });

        this.handleConnection(conn);
    }

    handleConnection(conn) {
        this.conn = conn;

        this.conn.on('open', () => {
            this.el.status.className = 'status-badge status-connected';
            this.el.status.textContent = 'Connected';
            showToast("Connected to " + this.conn.peer);
            
            // Switch view
            document.getElementById('view-setup').classList.add('hidden');
            document.getElementById('view-transfer').classList.remove('hidden');
        });

        this.conn.on('data', (data) => this.handleData(data));
        
        this.conn.on('close', () => {
            showToast("Connection Closed");
            this.resetApp();
        });
    }

    resetApp() {
        location.reload();
    }

    resetUI() {
        this.el.connectBtn.disabled = false;
        this.el.connectBtn.textContent = "Connect";
    }

    // --- UI HELPERS ---

    copyId() {
        navigator.clipboard.writeText(this.myId).then(() => showToast("ID Copied"));
    }

    toggleQR() {
        this.el.qr.classList.toggle('hidden');
    }

    generateQR(text) {
        this.el.qr.innerHTML = '';
        try {
            new QRCode(this.el.qr, {
                text: text,
                width: 128,
                height: 128,
                colorDark : "#000000",
                colorLight : "#ffffff",
                correctLevel : QRCode.CorrectLevel.L
            });
        } catch(e) {
            this.el.qr.innerHTML = '<small>QR Error</small>';
        }
    }

    // --- FILE TRANSFER ---

    handleFileSelect(input) {
        const file = input.files[0];
        if (!file) return;
        this.sendFile(file);
        input.value = '';
    }

    sendFile(file) {
        if (!this.conn || !this.conn.open) return showToast("Connection lost");

        const fileId = Date.now().toString();
        this.createTransferUI(fileId, file.name, file.size, true);

        // 1. Send Metadata
        this.conn.send({
            type: 'meta',
            id: fileId,
            name: file.name,
            size: file.size,
            mime: file.type
        });

        // 2. Chunked sending
        const fileReader = new FileReader();
        let offset = 0;

        fileReader.onload = (e) => {
            if (!this.transfers[fileId].active) return;
            
            // Send chunk wrapped in object to distinguish from control messages
            // PeerJS handles serialization
            this.conn.send({
                type: 'chunk',
                id: fileId,
                data: e.target.result // ArrayBuffer
            });

            offset += e.target.result.byteLength;
            this.updateProgress(fileId, offset, file.size);

            if (offset < file.size) {
                // Simple flow control: wait a tick
                // For a robust app, we'd check bufferedAmount, but PeerJS abstracts this.
                // We use setTimeout to prevent freezing the UI on large files.
                setTimeout(readSlice, 5); 
            } else {
                this.updateStatus(fileId, "Sent");
            }
        };

        const readSlice = () => {
            const slice = file.slice(offset, offset + CHUNK_SIZE);
            fileReader.readAsArrayBuffer(slice);
        };

        readSlice();
    }

    handleData(data) {
        if (data.type === 'meta') {
            this.transfers[data.id] = {
                fileName: data.name,
                fileSize: data.size,
                fileType: data.mime,
                receivedSize: 0,
                buffer: [],
                active: true
            };
            this.createTransferUI(data.id, data.name, data.size, false);
        
        } else if (data.type === 'chunk') {
            const t = this.transfers[data.id];
            if (t && t.active) {
                t.buffer.push(data.data);
                t.receivedSize += data.data.byteLength;
                
                this.updateProgress(data.id, t.receivedSize, t.fileSize);

                if (t.receivedSize >= t.fileSize) {
                    this.finalizeDownload(data.id);
                }
            }
        
        } else if (data.type === 'cancel') {
            if (this.transfers[data.id]) {
                this.transfers[data.id].active = false;
                this.updateStatus(data.id, "Cancelled by peer");
            }
        }
    }

    finalizeDownload(id) {
        const t = this.transfers[id];
        t.active = false;
        const blob = new Blob(t.buffer, { type: t.fileType });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = t.fileName;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        
        this.updateStatus(id, "Downloaded");
        setTimeout(() => URL.revokeObjectURL(url), 10000); 
    }

    // --- TRANSFER UI ---

    createTransferUI(id, name, size, isSender) {
        this.transfers[id] = this.transfers[id] || {};
        this.transfers[id].active = true;

        const el = document.createElement('div');
        el.className = 'card fade-in';
        el.id = `ui-${id}`;
        el.innerHTML = `
            <div class="flex-row">
                <strong>${isSender ? 'Sending:' : 'Receiving:'} ${name}</strong>
                <small>${formatBytes(size)}</small>
            </div>
            <div class="progress-bar"><div class="progress-fill" id="bar-${id}"></div></div>
            <div class="flex-row" style="margin-top: 5px;">
                <small id="stat-${id}">Preparing...</small>
                <button class="btn btn-small" onclick="app.cancelTransfer('${id}')" style="width: auto;">Cancel</button>
            </div>
        `;
        this.el.transfersList.prepend(el);
    }

    updateProgress(id, current, total) {
        const pct = Math.round((current / total) * 100);
        const bar = document.getElementById(`bar-${id}`);
        const stat = document.getElementById(`stat-${id}`);
        if (bar) bar.style.width = `${pct}%`;
        if (stat) stat.textContent = `${pct}%`;
    }

    updateStatus(id, msg) {
        const stat = document.getElementById(`stat-${id}`);
        if (stat) stat.textContent = msg;
    }

    cancelTransfer(id) {
        if (this.transfers[id]) {
            this.transfers[id].active = false;
            this.updateStatus(id, "Cancelled");
            if (this.conn && this.conn.open) {
                this.conn.send({ type: 'cancel', id: id });
            }
        }
    }
}

// Init App
const app = new GhostShare();

// Prevent accidental navigation
window.onbeforeunload = function() {
    if (app.conn && app.conn.open) {
        return "Active connection will be lost.";
    }
};
</script>
</body>
</html>


